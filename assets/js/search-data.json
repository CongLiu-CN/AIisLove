{
  
    
        "post0": {
            "title": "Story Telling and Communication",
            "content": "First, ask yourself: “Who’s it for?” . Then ask more questions base on it: . What questions will they have? | What needs do they have? | What concerns can you address before they arise? | .",
            "url": "https://www.ai4love.xyz//soft%20skill/2020/06/03/StoryTelling.html",
            "relUrl": "/soft%20skill/2020/06/03/StoryTelling.html",
            "date": " • Jun 3, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "The Bits and Bytes of Computer Networking",
            "content": "Key Concepts** . Describe how the TCP/IP five layer network model works. | Identify basic networking devices. | Label each of the five layers in the TCP/IP network model. | Describe how the physical layer works. | Describe how the data link layer works. | . The Start of Week 1 . . 1. The TCP/IP Five-Layer Network Model . . 1.1 Physical Layer . Represents the physical devices that interconnect computers . 1.2 Data Link Layer . Responsible for defining a common way of interpreting these signals so network devices can communicate . The Ethernet standards also define a protocol responsible for getting data to nodes on the same network or link. . 1.3 Network Layer . Allows different networks to communicate with each other through devices known as routers . Internetwork . A collection of networks connected together through routers, the most famous of these being the Internet . IP(Internet Protocol) . IP is the heart of the Internet and most small networks around the world. . 1.4 Transport Layer . Sorts out which client and server programs are supposed to get that data . TCP(Transmission Control Protocol) . UDP(User Datagram Protocol) . The big difference between the two is that TCP provides mechanisms to ensure that data is reliably delivered while UDP does not. . 1.5 Application Layer . The protocols at play in the application layer will be most familiar to you, since they are the ones you probably interacted with directly before, even if you didn’t realize it. . You can think of layers like different aspects of a package being delivered. . The physical layer is the delivery truck and the roads. . | The data link layer is how the delivery trucks get from one intersection to the next over and over. . | The network layer identifies which roads need to be taken to get from address A to address B. . | The transport layer ensures that delivery driver knows how to knock on your door to tell you your package has arrived. . | The application layer is the contents of the package itself. . | . 1.6 Supplementary Reading for The OSI Networking Model . In addition to the five layer model, it’s importance to note that other models exist. For example, the traditional TCP/IP Model only has four layers, as it doesn’t differentiate between the physical layer and the data link layer. The most well know other model is the OSI model. . The primary difference between our five layer model and the seven layer OSI model is that the OSI model abstracts the application layer into three layers total. . Learn more about the OSI Networking Model: . https://www.sans.org/reading-room/whitepapers/standards/osi-model-overview-543 | https://en.wikipedia.org/wiki/OSI_model | . 2. The Basics of Networking Devices . 2.1 Cables . Connect different devices to each other, allowing data to be transmitted over them . Most network cables used today can be split into two categories: . Copper (the most common form) | Fiber (Fiber Optic Cables) | . The most common forms of copper twisted-pair cables used in networking are Cat5, Cat5e, and Cat6 cables. . Differences in how these twisted pairs are arranged inside these cables can drastically alter how quickly data can be sent accross them and how resistent these signals are to outside interference. . Cat5e cables have mostly replaced those older Cat5 cables because their internals reduce crosstalk. . Crosstalk . When an electrical pulse on one wire is accidentally detected on another wire . Cat6 cables follow an even more strict specification to avoid crosstalk, making those cables more expensive. Cat6 cables can transfer data faster and more reliably than Cat5e cables can, but because their internal arrangement, they have a shorter maximium distance when used at higher speeds. . Fiber Cables . Contain individual optical fibers, which are tiny tubes made out of glass about the width of a human hair . Unlike copper, which uses electrical voltages, fiber cables use pulses of light to represent the ones and zeros of the underlying data. . Fiber is even sometimes used specifically in environments where there’s a lot of electromagnetic interference from outside sources. Because this can impact data being sent across copper wires. . Fiber cables can generally transport data quicker than copper cables can, but they’re much more expensive and fragile. Fiber can also transport data over much longer distances than copper can without suffering potential data loss. . 2.2 Hubs and Switches . Unlike cables, which allow you to form point-to-point networking connections, there are network devices that allow for many computers to communicate with each other. The most simple of these devices is a hub. . Hub . A physical layer device that allows for connections from many computers at once. . . All devices connected to a hub will end up talking to all other devices at the same time. It’s up to each system connected to the hub to determine if the incoming data was meant for them, or to ignore it if it isn’t. These causes a lot of noise on the network and creates what’s called a collision domain. . Collision Domain . A network segment where only one device can communicate at a time. . If multiple systems try sending data at the same time, the electrical pulses sent across the cable can interfere with each other. . These slows down network communications, and is the primary reason hubs are fairly rare. They’re mostly a historical artifact today. A much more common way of connecting many computers is with a more sophisticated device, known as a network switch, originally known as a switching hub. . . A switch is very similar to a hub, since you can connect many devices to it so they can communicate. The difference is that while a hub is a layer 1 or physical layer device, a switch is a level 2 or data link device. . . This means that a switch can actually inspect the contents of the Ethernet protocol data being sent around the network, determine which system the data is intended for and then only send that data to that one system. This reduces or even completely eliminates the size of collision domains on a network. . 2.3 Routers . Hubs and switches . The primary devices used to connect computers on a single network, usually referred to as a LAN, or local area network . Router . A device that knows how to forward data between independent networks . While a hub is a layer 1 device and a switch is a layer 2 device. A router operates at layer 3, a network layer. . . Just like a switch can inspect Ethernet data to determine where to send things, a router can inspect IP data to determine where to send things. . . Routers store internal tables containing information about how to route traffic between lots of different networks all over the world. The most common type of router you’ll see is one for a home network, or a small office. These devices generally don’t have very detailed routing tables. The purpose of these routes is mainly just to take traffic originating from inside the home, or office LAN, and to forward it along to the ISP, or Internet Service Provider. Once traffic is at the ISP, a way more sophisticated type of router takes over. These core routers from the backbone of the Internet and are directly responsible for how we send and receive data all over the Internet every single day. Core ISP routers don’t just handle a lot more traffic than a home or a small office router. They also have to deal with much more complexity in making decision about where to send traffic. . . A core router usually has many different connections to many other routers. Routers share data with each other via a protocol known as BGP, or Border Gateway Protocol. . Border Gateway Protocol . Routers share data with each other via this protocol, which lets them learn about the most optimal paths to forward traffic . When you open a web browser and load a webpage, the traffic between computers and the web servers could have traveled over dozens of different routers. The Internet is incredibly large and complicated. And routers are global guides for getting traffic to the right places. . 2.4 Servers and Clients . The simplest way to think of server is as something that provides data to something requesting that data. The thing receiving the data is referred to as a client. . A server is anything that can provide data to a client, but we can also use the word to refer to the primary purpose of various nodes on our network. . . 3. The Physical Layer . 3.1 Moving Bits Across the Wire . In some ways, the physical layer of our network stack model is the most complexible. Its main focus is on moving ones and zeros from one end of the link to the next. The physical layer consists of devices and means of transmitting bit across computer networks. . Bit . The smallest representation of data that a computer can understand; it’s a one or a zero . These ones and zeros send across networks at the lowest level are what make up the frames and packets of data. The takeaway is that it doesn’t matter whether you’re streaming your favorite song, emailing your boss, or using an ATM, what you’re really doing is sending ones and zeros across the physical layer of the many different networks between you and the server you’re interacting with. . A standard copper network table, once connected to devices on both ends, will carry a constant electrical charge. Ones and zeros are sent across those network cables through a process called modulation. . Modulation . A way of varying the voltage of this charge moving across the cable . When used for computer networks, this kind of modulation is more specifically known as line coding. It allows devices on either end of a link to understand that an electrical charge in a certain state is a zero, and in another state is a one. Through this seemingly simple techniques, modern networks are capable of moving 10 billion ones and zeros across a single network cable every second. . . 3.2 Twisted Pair Cabling and Duplexing . The most common type of cabling used for connecting computing devices is known as twisted pair. It’s called a twisted pair cable because it features pairs of copper wires that are twisted together. These pairs act as a single conduit for information, and their twisted nature helps protect against electromagnetic interference and crosstalk from neighboring pairs. . . A standard Cat6 cable has eight wires consisting of four twisted pairs inside a single jacket. Exactly how many pairs are actually in use depends on the transmission technology being used. But in all modern forms of networking, it’s important to know that these cables allow for duplex communication. . Duplex communication . The concept that information can flow in both directions across the cable . Simplex communication . This process is unidirectional . Think about a baby monitor, where the transmission of data only goes in one direction making it a simplex communication. A phone call on the other hand is duplex since both parties can listen and speak. . . The way networking cables ensure that duplex communication is possible is by reserving one or two pairs for communication in one direction. They then use other one or two pairs for communicating in the other direction. So, devices on either side of a networking link can both communicate with each other at the exact same time. This is known as full duplex. . . If there’s something wrong with the connection, you might see a network link degrade and report itself as operating as half-duplex. Half-duplex means that, while communication is possible in each direction, only one device can be communicating at a time. . 3.3 Supplemental Reading for Ethernet Over Twisted Pair Technologies . Ethernet over twisted pair technologies are the communications protocols that determine how much data can be sent over a twisted pair cable, how quickly that data can be sent, and how long a network cable can be before the data quality begins to degrade. . Read more about Ethernet over Twisted Pair technologies: . https://en.wikipedia.org/wiki/Ethernet_over_twisted_pair . 3.4 Network Ports and Patch Panels . The final steps of how the physical layer works take place at the end points of our network links. Twisted Pair network cables are terminated with a plug that takes the individual internal wires and exposes them. The most common plug is knows as an RJ-45 or Registered Jack 45. . . It’s one of many cable plugs specifications but by far the most common in computer networking. A network cable with an RJ-45 plug can connect to an RJ-45 network port. . Network ports are generally directly attached to the devices that make up a computer network. . Switches would have many network ports because their purpose is to connect many devices. But servers and desktops usually only have one or two. Your laptop, tablet or phone probably don’t have any. . . Most network ports have two small LEDs. One is the link light and the other is the activity light. The link light will be lit when a cable is properly connected to two devices that are both powered on. The activity light will flash when data is actively transmitted across the cable. A long time ago, the flashing in the activity light corresponded directly to the one’s and zero’s being sent. Today, computer networks are so fast that the activity light doesn’t really communicate much other than if there’s any traffic or not. On switches, sometimes the same LED is used for both link and activity status. It might even indicate other things like links speed. You’ll have to read up on a particular piece of hardware you’re working with but there will almost always be some troubleshooting data available to you through port lights. Sometimes a network port isn’t connected directly to a device. Instead, there might be network ports mounted in a wall or underneath your desk. These ports are generally connected to the network via cables ran through the walls that eventually end at a patch panel. . . A patch panel is a device containing many net ports but it does no other work. It’s just a container for the endpoints of many runs of cable. Additional cables are then generally ran from a patch panel to switches or routers to provide network access to the computers at the other end of those links. . 4. The Data Link Layer . 4.1 Ethernet and MAC Addresses . It is quite surprising to know that traditional cable networks are still the most common option in the workplace and definitely in the data center. The protocol most widely used to send data across individual links is known as Ethernet. Ethernet and the data link layer provide a means for software at higher levels of the stack to send and receive data. One of the primary purposes of this layer is to essentially abstract away the need for any other layer to care about the physical layer and what hardware is in use. By dumping this responsibility on the data link layer, the Internet, transport and application layers can all operate the same no matter how the device they’re running on is connected. So, for example, your web browser doesn’t need to know if it’s running on a device connected via a twisted pair or a wireless connection. It just needs the underlying layers to send and receive data for it. . . Key concepts of this section: . What MAC addresses are and how they’re used to identify computers. | The various components that make up an Ethernet frame. | Differences between Unicast, Multicast and Broadcast addresses. | How cyclical redundancy checks help ensure the integrity of data sent via Ethernet. | . Ethernet is a fairly old technology. It first came into being in 1980 and saw its first fully polished standardization in 1983. Since then, a few changes have been introduced primarily in order to support ever-increasing bandwidth needs. For the most part though, the Ethernet in use today is comparable to the Ethernet standards as first published all those years ago. . In 1983, computer networking was totally different than it is today. One of the notable differences in land topology was that the switch or switchable hub hadn’t been invented yet. This meant that frequently, many or all devices on a network shared a single collision domain. You might remember from our discussion about hubs and switches that a collision domain is a network segment where only one device can speak at a time. This is because all data in a collision domain is sent to all the notes connected to it. If two computers were to send data across the wire at the same time, this would result in literal collisions of the electrical current representing our ones and zeros, leaving the end result unintelligible. Ethernet, as a protocol, solved this problem by using a technique known as Carrier Sense Multiple Access with Collision Detection(CSMA/CD). . CSMA/CD . Used to determine when the communications channels are clear, and when a device is free to transmit data . The way CSMA/CD works is actually pretty simple. If there’s no data currently being transmitted on the network segment, a node will feel free to send data. If it turns out that two or more computers end up trying to send data at the same time, the computers detect this collision and stop sending data. Each device involved with the collision then waits a random interval of time before trying to send data again. This random interval helps to prevent all the computers involved in the collision from colliding again the next time they try to transmit anything. When a network segment is a collision domain, it means that all devices on that segment receive all communication across the entire segment. This means we need a way to identify which node the transmission was actually meant for. This is where something known as a media access control address or MAC address comes into play. . MAC address . A globally unique identifier attached to an individual network interface . It’s a 48-bit number normally represented by six groupings of two hexadecimal numbers. . Hexadecimal . A way to represent numbers using 16 digits . Just like how binary is a way to represent numbers with only two digits, hexadecimal is a way to represent numbers using 16 digits. Since we don’t have numerals to represent any individual digit larger than nine, hexadecimal numbers employed the letters A, B, C, D, E, and F to represent the numbers 10, 11, 12, 13, 14, and 15. . . Another way to reference each group of numbers in a MAC address is an octet. . Octet . In computer networking, any number that can be represented by 8 bits . You might wonder how could MAC addresses be globally unique. The short answer is that a 48-bit number is much larger than you might expect. The total number of a possible MAC addresses that could exist is 2^48 or 281,474,976,710,656 unique possibilities. . A MAC address is split into two sections. . Organizationally Unique Identifier (OUI) . The first three octets of a MAC address . The first three octets of a MAC address are assigned to individual hardware manufactures by the IEEE or the Institute of Electrical and Electronics Engineers, which means you can always identify the manufacturer of a network interface purely by its MAC address. . . The last three octets of a MAC address can be assigned in any way that the manufacturer would like with the condition that they are only assigned each possible address once to keep all MAC addresses globally unique. . Ethernet uses MAC addresses to ensure that the data it sends has both an address for the machine that sent the transmission, as well as the one the transmission was intended for. . In this way, even on a network segment, acting as a single collision domain, each node on that network knows when traffic is intended for it. . 4.2 Unicast, Multicast, and Broadcast . 4.3 Dissecting an Ethernet Frame . . The End of Week 1 . The Start of Week 2 . . 5. The Network Layer . 5.1 The Network Layer . . On a local area network or LAN, nodes can communicate with each other through their physical MAC addresses. This works well on small scale because switches can quickly learn the MAC addresses connected to each other ports to forward transmissions appropriately. But MAC addresses isn’t a scheme that scales well, every single network interface on the planet has a unique MAC address and they aren’t ordered in any systematic way. There is no way of knowing where on the planet a certain MAC address might be at any one point in time, so it’s not ideal for communicating across distances. Later on in this lesson, when we introduce ARP (Address Resolution Protocol), you’ll see that the way that nodes learn about each other’s physical addressing isn’t translatable to anything besides a single network signet anyway. Clearly we need another solution, and that is the network layer, and the internet protocol (IP) in the IP addresses that come along with it. By the end of this lesson you’ll be able to take identify an IP address, describe how IP datagrams are encapsulated inside the payload of an ethernet frame and correctly identify and describe the many fields of an IP datagram header. . 5.2 IP Addresses . IP addresses are 32-bit-long numbers made up of four octets, and each octet is normally described in decimal numbers. 8 bits of data or a single octet can represent all decimal numbers from 0 to 255. For example, 12.30.56.78 is a valid IP address, but 123.456.789.100 would not be because it has numbers larger than what could be represented by 8 bits. This format is known as dotted decimal notation. . . We will deep dive into how some of this works in an upcoming lesson about subnetting. The important thing to know for now is that IP addresses are distributed in large sections to various organizations and companies instead of being determined by hardware vendors. This means that IP addresses are more hierarchical and easier to store data than physical addresses are. Think of IBM, which owns every single IP that has the number 9 as the first octet. At a very high level, this means that if an internet router needs to figure out where to send a data packet intended for the IP address 9.0.0.1, that router only has know to get it to one of IBM’s routers. That router can handle the rest of the delivery process from there. . IP addresses belong to networks, not to . the devices attached to those networks. . It’s important to call out that IP addresses belong to the networks, not the devices attached to those networks. So your laptop will always have the same MAC address no matter where you use it, but it will have a different IP address assigned to it at an Internet café than it would when you’re at home. The LAN at the Internet café, or the LAN at your house would each be individually responsible for handling out an IP address to your laptop if you power it on there. On a day-to-day basis, getting an IP address is usually a pretty invisible process. For now, remember that on many modern networks you can connect a new device and an IP address will be assigned to it automatically through a technology known as Dynamic Host Configuration Protocol (DHCP). An IP address assigned this way is known as a Dynamic IP address. The opposite of this is known as a Static IP address, which must be configured on a node manually. . In most cases static IP addresses are reserved for servers and network devices, . while dynamic IP addresses are reserved for clients. . But there are certainly situations where this might not be true. .",
            "url": "https://www.ai4love.xyz//computer%20science/2020/06/02/BitsAndBytesOfComputerNetwork.html",
            "relUrl": "/computer%20science/2020/06/02/BitsAndBytesOfComputerNetwork.html",
            "date": " • Jun 2, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "How I was rejected by 600 companies and still be OK",
            "content": "I returned to Beijing on 8 May in 2020 to find a developer job. Machine learning and data analysis are my top two priorities. Unfortunately, I was rejected by over 600 companies. . Being rejected doesn’t feel good. In fact, it could possibly mentally destroy a person. Before we delve into the psychology part, let me tell you a story. . When I was a kid, my parents used to lock me inside my room so I couldn’t go anywhere and get into trouble, because they had to work and no one would be looking after me. That’s a tough choice they had to make. At that time, I was cool being locked. I can play with my toys all day. When my parents came back, they were always surprised by the fact that I was still calm. It seems I was born enjoy being alone. . However, I wasn’t enjoy loneliness. I knew there was nothing I can do to keep my parents by my side, so I chose to find a way to deal with being alone. Now over 600 recruiters rejected me, saying I am not qualified to be a developer in their company. Should I believe them and stop coding? Of course no. If I did, I might never be qualified to be a great developer. If I believed whatever they said, I would make their words a reality. If I doubt myself when everyone leaves me, I would be struggling in that locked room ten years ago. I always have faith in myself, I would be the one who proceeds when everyone else has given up. I am not stop coding just because I couldn’t be coding and paid at the same time. Those rejections are just facts that I have no control of. Living is all about focusing on those things that we can control. . How could I be so cool being rejected 600 times? By admitting I wasn’t good enough for now. By focusing on what I can control which means I need to strengthen my coding skills and build more projects. In this life, all the results are just byproducts that take time. Living in the moment means we have to focus on the present and take action. That’s the mindset of a practitioner, that’s the mindset of a great developer, and that was also the mindset of a young kid who had been locked in a tiny room and still be happy. .",
            "url": "https://www.ai4love.xyz//mindset/2020/05/22/RejectedBy600.html",
            "relUrl": "/mindset/2020/05/22/RejectedBy600.html",
            "date": " • May 22, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Defeat The Demon",
            "content": "If you don’t go back to your childhood and touch those uncomfortable feelings, they will come back to you and hurt you repeatedly. . I’ve been very upset and stressed these days, away from home, jobless for over 3 months, and intensively pushing myself which almost made me crazy. Tonight, I went for a walk in a park near my apartment, through my Airpods Pro, listening to a podcast that made me rethinking about my life, which was Jay Shetty interviewing David Goggins. . Through that talk, they mentioned childhood traumas, which is the bad things happened to us during our childhood. David Goggins was beaten by his father, yet now a strong man that seems nothing bad could happen to him. He argued that we all need to go back to our childhood in our minds and revisit the horrible memories at young age. This view really made me shocked! I tried to search some bad memories in my mind but I couldn’t. It seems that all of them has been protected by my brain. It somehow covered and hided all the bad things in my childhood. When I tried harder, my brain send me a warning to stop and a strong sense of pain. That moment, I realized the existence of my childhood traumas. My brain was naturally designed to seek happiness and avoid pain. However, it is important to start to solve the problems instead of leaving them and let them grow heavier. . Since I started to remember things, I spent most of my time sitting on a bed, playing with toys or cards. My parents weren’t there always. They had to work and only came back regularly to check if I was fine, while staying out of my site. Sometimes, I was happy they are back. While mostly, I didn’t notice if they were back because I was so concentrated on the self-created games in front of me. I could spend hours with a deck of cards as well as half a day with a few toys. I created characters for each toy and my imagination had no limits. I think at that young age, I was smart enough to know it was the only way that I could remain sane without the accompany of my parents. I was smart enough to fool myself. . I was always smart. I was smart and I didn’t want others to know. I was pretending to be a fool, so that my parents could put more time on me. I enjoyed when they were around and upset when they weren’t. Due to the lack of parents’ care in my childhood, I am still seeking more time to spend with my parents in my adulthood. They can’t understand why I stay at home a lot. But I was smart enough to know that nothing is more important than my parents. . I was smart enough to question the education system. It taught us everything from the book but failed to teach how to live. The knowledge were outdated and the teachers were all once bad students. My parents always had a high expectation on me, spending a lot money on my education. I was smart enough to know that the money were wasted. I was and I still am guilty that I couldn’t stop them to do so. . I was smart enough to know that working hard doesn’t always bring more money. I did a lot of jobs and none of them lasts. I was constantly changing jobs and fields. I was first a construction worker, then a chemical technician, then an English teacher… My parents were upset that I didn’t settle down. I was and am still guilty for this. . Now, I’ve revisited three demons in my mind—the lack of accompany, the money wasted on education, and the unsettled life. I am confronting them and trying to defeat them. This should be a habit, cause it’s the only way I can remove the wounds in my mind and not let them grow. This won’t be easy, but it will be worth it. .",
            "url": "https://www.ai4love.xyz//mindset/2020/05/16/DefeatTheDemon.html",
            "relUrl": "/mindset/2020/05/16/DefeatTheDemon.html",
            "date": " • May 16, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Predicting the Sale Price of Bulldozers using Machine Learning",
            "content": "1. Problem definition . How well can we predict the future sale price for a bulldozer, given its characteristics and previous examples of how much similar bulldozers have been sold for? . 2. Data . The data is downloaded from the Kaggle Bluebook for Bulldozers compitition:https://www.kaggle.com/c/bluebook-for-bulldozers/data There are 3 main datasets: . Train.csv is the training set, which contains data through the end of 2011. | Valid.csv is the validation set, which contains data from January 1, 2012 - April 30, 2012 You make predictions on this set throughout the majority of the competition. Your score on this set is used to create the public leaderboard. | Test.csv is the test set, which won&#39;t be released until the last week of the competition. It contains data from May 1, 2012 - November 2012. Your score on the test set determines your final rank for the competition. | . 3. Evaluation . The evaluation metric for this competition is the RMSLE (root mean squared log error) between the actual and predicted auction prices. . For more on the evaluation of this project check: https://www.kaggle.com/c/bluebook-for-bulldozers/overview/evaluation . Note: The goal for most regression evaluation metrics is to minimize the error. For example, our goal for this project will be to build a machine learning model which minimises RMSLE. . 4. Features . Kaggle provides a data dictionary detailing all of the features of the dataset. You can view this data dictionary on Google Sheets: https://docs.google.com/spreadsheets/d/18ly-bLR8sbDJLITkWG7ozKm8l3RyieQ2Fpgix-beSYI/edit?usp=sharing . import pandas as pd import numpy as np import matplotlib.pyplot as plt import sklearn . # Import training and validation sets df = pd.read_csv(&quot;data/TrainAndValid.csv&quot;, low_memory=False) . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 412698 entries, 0 to 412697 Data columns (total 53 columns): # Column Non-Null Count Dtype -- -- 0 SalesID 412698 non-null int64 1 SalePrice 412698 non-null float64 2 MachineID 412698 non-null int64 3 ModelID 412698 non-null int64 4 datasource 412698 non-null int64 5 auctioneerID 392562 non-null float64 6 YearMade 412698 non-null int64 7 MachineHoursCurrentMeter 147504 non-null float64 8 UsageBand 73670 non-null object 9 saledate 412698 non-null object 10 fiModelDesc 412698 non-null object 11 fiBaseModel 412698 non-null object 12 fiSecondaryDesc 271971 non-null object 13 fiModelSeries 58667 non-null object 14 fiModelDescriptor 74816 non-null object 15 ProductSize 196093 non-null object 16 fiProductClassDesc 412698 non-null object 17 state 412698 non-null object 18 ProductGroup 412698 non-null object 19 ProductGroupDesc 412698 non-null object 20 Drive_System 107087 non-null object 21 Enclosure 412364 non-null object 22 Forks 197715 non-null object 23 Pad_Type 81096 non-null object 24 Ride_Control 152728 non-null object 25 Stick 81096 non-null object 26 Transmission 188007 non-null object 27 Turbocharged 81096 non-null object 28 Blade_Extension 25983 non-null object 29 Blade_Width 25983 non-null object 30 Enclosure_Type 25983 non-null object 31 Engine_Horsepower 25983 non-null object 32 Hydraulics 330133 non-null object 33 Pushblock 25983 non-null object 34 Ripper 106945 non-null object 35 Scarifier 25994 non-null object 36 Tip_Control 25983 non-null object 37 Tire_Size 97638 non-null object 38 Coupler 220679 non-null object 39 Coupler_System 44974 non-null object 40 Grouser_Tracks 44875 non-null object 41 Hydraulics_Flow 44875 non-null object 42 Track_Type 102193 non-null object 43 Undercarriage_Pad_Width 102916 non-null object 44 Stick_Length 102261 non-null object 45 Thumb 102332 non-null object 46 Pattern_Changer 102261 non-null object 47 Grouser_Type 102193 non-null object 48 Backhoe_Mounting 80712 non-null object 49 Blade_Type 81875 non-null object 50 Travel_Controls 81877 non-null object 51 Differential_Type 71564 non-null object 52 Steering_Controls 71522 non-null object dtypes: float64(3), int64(5), object(45) memory usage: 166.9+ MB . df.isna().sum() . SalesID 0 SalePrice 0 MachineID 0 ModelID 0 datasource 0 auctioneerID 20136 YearMade 0 MachineHoursCurrentMeter 265194 UsageBand 339028 saledate 0 fiModelDesc 0 fiBaseModel 0 fiSecondaryDesc 140727 fiModelSeries 354031 fiModelDescriptor 337882 ProductSize 216605 fiProductClassDesc 0 state 0 ProductGroup 0 ProductGroupDesc 0 Drive_System 305611 Enclosure 334 Forks 214983 Pad_Type 331602 Ride_Control 259970 Stick 331602 Transmission 224691 Turbocharged 331602 Blade_Extension 386715 Blade_Width 386715 Enclosure_Type 386715 Engine_Horsepower 386715 Hydraulics 82565 Pushblock 386715 Ripper 305753 Scarifier 386704 Tip_Control 386715 Tire_Size 315060 Coupler 192019 Coupler_System 367724 Grouser_Tracks 367823 Hydraulics_Flow 367823 Track_Type 310505 Undercarriage_Pad_Width 309782 Stick_Length 310437 Thumb 310366 Pattern_Changer 310437 Grouser_Type 310505 Backhoe_Mounting 331986 Blade_Type 330823 Travel_Controls 330821 Differential_Type 341134 Steering_Controls 341176 dtype: int64 . df.columns . Index([&#39;SalesID&#39;, &#39;SalePrice&#39;, &#39;MachineID&#39;, &#39;ModelID&#39;, &#39;datasource&#39;, &#39;auctioneerID&#39;, &#39;YearMade&#39;, &#39;MachineHoursCurrentMeter&#39;, &#39;UsageBand&#39;, &#39;saledate&#39;, &#39;fiModelDesc&#39;, &#39;fiBaseModel&#39;, &#39;fiSecondaryDesc&#39;, &#39;fiModelSeries&#39;, &#39;fiModelDescriptor&#39;, &#39;ProductSize&#39;, &#39;fiProductClassDesc&#39;, &#39;state&#39;, &#39;ProductGroup&#39;, &#39;ProductGroupDesc&#39;, &#39;Drive_System&#39;, &#39;Enclosure&#39;, &#39;Forks&#39;, &#39;Pad_Type&#39;, &#39;Ride_Control&#39;, &#39;Stick&#39;, &#39;Transmission&#39;, &#39;Turbocharged&#39;, &#39;Blade_Extension&#39;, &#39;Blade_Width&#39;, &#39;Enclosure_Type&#39;, &#39;Engine_Horsepower&#39;, &#39;Hydraulics&#39;, &#39;Pushblock&#39;, &#39;Ripper&#39;, &#39;Scarifier&#39;, &#39;Tip_Control&#39;, &#39;Tire_Size&#39;, &#39;Coupler&#39;, &#39;Coupler_System&#39;, &#39;Grouser_Tracks&#39;, &#39;Hydraulics_Flow&#39;, &#39;Track_Type&#39;, &#39;Undercarriage_Pad_Width&#39;, &#39;Stick_Length&#39;, &#39;Thumb&#39;, &#39;Pattern_Changer&#39;, &#39;Grouser_Type&#39;, &#39;Backhoe_Mounting&#39;, &#39;Blade_Type&#39;, &#39;Travel_Controls&#39;, &#39;Differential_Type&#39;, &#39;Steering_Controls&#39;], dtype=&#39;object&#39;) . Do you know how to plot a figure using matlotlib.plt? . Let&#39;s plot a figure with saledate as its x-label and SalePrice as its y-label. . Since there are too many data, we only plot the first 1000. . fig, ax = plt.subplots() ax.scatter(df[&quot;saledate&quot;][:1000], df[&quot;SalePrice&quot;][:1000]) . &lt;matplotlib.collections.PathCollection at 0x55535b0&gt; . Why is the x-label messed up? Let&#39;s check it. . df.saledate[:1000] . 0 11/16/2006 0:00 1 3/26/2004 0:00 2 2/26/2004 0:00 3 5/19/2011 0:00 4 7/23/2009 0:00 ... 995 7/16/2009 0:00 996 6/14/2007 0:00 997 9/22/2005 0:00 998 7/28/2005 0:00 999 6/16/2011 0:00 Name: saledate, Length: 1000, dtype: object . It looks weird! Let&#39;s check the data type of saledate... . df.saledate.dtype . dtype(&#39;O&#39;) . Oh! It&#39;s Object, maybe that&#39;s why x-label messed up... . But we are not sure, let&#39;s go further! . df.SalePrice.plot.hist() . &lt;matplotlib.axes._subplots.AxesSubplot at 0xb016850&gt; . The lower the price, the more its sales. . Parsing dates . When we work with time series data, we want to enrich the time &amp; date component as much as possible. . We can do that by telling pandas which of our columns has dates in it using the parse_dates parameter. . # Import data again but this time parse dates df = pd.read_csv(&quot;data/TrainAndValid.csv&quot;, low_memory=False, parse_dates=[&quot;saledate&quot;]) . df.saledate.dtype . dtype(&#39;&lt;M8[ns]&#39;) . Before: Object | After: &lt;M8[ns] . But what is &lt;M8[ns]? . Well, &lt;M8[ns] &amp; datetime64[ns] are basically the same thing, at least on my laptop (whose byte order is little endian): https://stackoverflow.com/questions/29206612/difference-between-data-type-datetime64ns-and-m8ns . | datetime64[ns] is data type in Numpy that represents a date or a time. It was named this way because datetime has been taken by Python. . | . np.dtype(&#39;datetime64[ns]&#39;) == np.dtype(&#39;&lt;M8[ns]&#39;) . True . So, this means after parsing dates, the data type of the saledate column is a kind of datetime. . Let&#39;s check the first 1000 rows of saledate column: . df.saledate[:1000] . 0 2006-11-16 1 2004-03-26 2 2004-02-26 3 2011-05-19 4 2009-07-23 ... 995 2009-07-16 996 2007-06-14 997 2005-09-22 998 2005-07-28 999 2011-06-16 Name: saledate, Length: 1000, dtype: datetime64[ns] . Wow, this data type looks clearner and more readable than what we have seen before. . The purpose of this date parsing is to regulate the x-label in the figure. . fig, ax = plt.subplots() ax.scatter(df[&quot;saledate&quot;][:1000], df[&quot;SalePrice&quot;][:1000]) . &lt;matplotlib.collections.PathCollection at 0xb6b3070&gt; . Looks matplotlib can understand this &lt;M8[ns] data type. Great! . Let&#39;s do more EDA(exploratory data analysis): . df.head() . SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand saledate ... Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls . 0 1139246 | 66000.0 | 999089 | 3157 | 121 | 3.0 | 2004 | 68.0 | Low | 2006-11-16 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | Standard | Conventional | . 1 1139248 | 57000.0 | 117657 | 77 | 121 | 3.0 | 1996 | 4640.0 | Low | 2004-03-26 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | Standard | Conventional | . 2 1139249 | 10000.0 | 434808 | 7009 | 121 | 3.0 | 2001 | 2838.0 | High | 2004-02-26 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 3 1139251 | 38500.0 | 1026470 | 332 | 121 | 3.0 | 2001 | 3486.0 | High | 2011-05-19 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 4 1139253 | 11000.0 | 1057373 | 17311 | 121 | 3.0 | 2007 | 722.0 | Medium | 2009-07-23 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 5 rows × 53 columns . Everytime we deal with a dataframe with long width, we can do Transpose(转置矩阵). https://en.wikipedia.org/wiki/Transpose . df.head().T . 0 1 2 3 4 . SalesID 1139246 | 1139248 | 1139249 | 1139251 | 1139253 | . SalePrice 66000 | 57000 | 10000 | 38500 | 11000 | . MachineID 999089 | 117657 | 434808 | 1026470 | 1057373 | . ModelID 3157 | 77 | 7009 | 332 | 17311 | . datasource 121 | 121 | 121 | 121 | 121 | . auctioneerID 3 | 3 | 3 | 3 | 3 | . YearMade 2004 | 1996 | 2001 | 2001 | 2007 | . MachineHoursCurrentMeter 68 | 4640 | 2838 | 3486 | 722 | . UsageBand Low | Low | High | High | Medium | . saledate 2006-11-16 00:00:00 | 2004-03-26 00:00:00 | 2004-02-26 00:00:00 | 2011-05-19 00:00:00 | 2009-07-23 00:00:00 | . fiModelDesc 521D | 950FII | 226 | PC120-6E | S175 | . fiBaseModel 521 | 950 | 226 | PC120 | S175 | . fiSecondaryDesc D | F | NaN | NaN | NaN | . fiModelSeries NaN | II | NaN | -6E | NaN | . fiModelDescriptor NaN | NaN | NaN | NaN | NaN | . ProductSize NaN | Medium | NaN | Small | NaN | . fiProductClassDesc Wheel Loader - 110.0 to 120.0 Horsepower | Wheel Loader - 150.0 to 175.0 Horsepower | Skid Steer Loader - 1351.0 to 1601.0 Lb Operat... | Hydraulic Excavator, Track - 12.0 to 14.0 Metr... | Skid Steer Loader - 1601.0 to 1751.0 Lb Operat... | . state Alabama | North Carolina | New York | Texas | New York | . ProductGroup WL | WL | SSL | TEX | SSL | . ProductGroupDesc Wheel Loader | Wheel Loader | Skid Steer Loaders | Track Excavators | Skid Steer Loaders | . Drive_System NaN | NaN | NaN | NaN | NaN | . Enclosure EROPS w AC | EROPS w AC | OROPS | EROPS w AC | EROPS | . Forks None or Unspecified | None or Unspecified | None or Unspecified | NaN | None or Unspecified | . Pad_Type NaN | NaN | NaN | NaN | NaN | . Ride_Control None or Unspecified | None or Unspecified | NaN | NaN | NaN | . Stick NaN | NaN | NaN | NaN | NaN | . Transmission NaN | NaN | NaN | NaN | NaN | . Turbocharged NaN | NaN | NaN | NaN | NaN | . Blade_Extension NaN | NaN | NaN | NaN | NaN | . Blade_Width NaN | NaN | NaN | NaN | NaN | . Enclosure_Type NaN | NaN | NaN | NaN | NaN | . Engine_Horsepower NaN | NaN | NaN | NaN | NaN | . Hydraulics 2 Valve | 2 Valve | Auxiliary | 2 Valve | Auxiliary | . Pushblock NaN | NaN | NaN | NaN | NaN | . Ripper NaN | NaN | NaN | NaN | NaN | . Scarifier NaN | NaN | NaN | NaN | NaN | . Tip_Control NaN | NaN | NaN | NaN | NaN | . Tire_Size None or Unspecified | 23.5 | NaN | NaN | NaN | . Coupler None or Unspecified | None or Unspecified | None or Unspecified | None or Unspecified | None or Unspecified | . Coupler_System NaN | NaN | None or Unspecified | NaN | None or Unspecified | . Grouser_Tracks NaN | NaN | None or Unspecified | NaN | None or Unspecified | . Hydraulics_Flow NaN | NaN | Standard | NaN | Standard | . Track_Type NaN | NaN | NaN | NaN | NaN | . Undercarriage_Pad_Width NaN | NaN | NaN | NaN | NaN | . Stick_Length NaN | NaN | NaN | NaN | NaN | . Thumb NaN | NaN | NaN | NaN | NaN | . Pattern_Changer NaN | NaN | NaN | NaN | NaN | . Grouser_Type NaN | NaN | NaN | NaN | NaN | . Backhoe_Mounting NaN | NaN | NaN | NaN | NaN | . Blade_Type NaN | NaN | NaN | NaN | NaN | . Travel_Controls NaN | NaN | NaN | NaN | NaN | . Differential_Type Standard | Standard | NaN | NaN | NaN | . Steering_Controls Conventional | Conventional | NaN | NaN | NaN | . df.saledate.head(20) . 0 2006-11-16 1 2004-03-26 2 2004-02-26 3 2011-05-19 4 2009-07-23 5 2008-12-18 6 2004-08-26 7 2005-11-17 8 2009-08-27 9 2007-08-09 10 2008-08-21 11 2006-08-24 12 2005-10-20 13 2006-01-26 14 2006-01-03 15 2006-11-16 16 2007-06-14 17 2010-01-28 18 2006-03-09 19 2005-11-17 Name: saledate, dtype: datetime64[ns] . Sort DataFrame by saledate . When working with time series data, it&#39;s a good idea to sort it by date. . # Sort DataFrame in date order df.sort_values(by=[&quot;saledate&quot;], inplace=True, ascending=True) df.saledate.head(20) . 205615 1989-01-17 274835 1989-01-31 141296 1989-01-31 212552 1989-01-31 62755 1989-01-31 54653 1989-01-31 81383 1989-01-31 204924 1989-01-31 135376 1989-01-31 113390 1989-01-31 113394 1989-01-31 116419 1989-01-31 32138 1989-01-31 127610 1989-01-31 76171 1989-01-31 127000 1989-01-31 128130 1989-01-31 127626 1989-01-31 55455 1989-01-31 55454 1989-01-31 Name: saledate, dtype: datetime64[ns] . Make a copy of the original DataFrame . We make a copy of the original dataframe so when we manipulate the copy, we&#39;ve still got our original data. . # Make a copy of the original DataFrame to perform edits on df_tmp = df.copy() . What we are about to do is called Feature Engineering. . Add datetime parameters for saledate column . df_tmp[&quot;saleYear&quot;] = df_tmp.saledate.dt.year df_tmp[&quot;saleMonth&quot;] = df_tmp.saledate.dt.month df_tmp[&quot;saleDay&quot;] = df_tmp.saledate.dt.day df_tmp[&quot;saleDayOfWeek&quot;] = df_tmp.saledate.dt.dayofweek df_tmp[&quot;saleDayOfYear&quot;] = df_tmp.saledate.dt.dayofyear . df_tmp.head().T . 205615 274835 141296 212552 62755 . SalesID 1646770 | 1821514 | 1505138 | 1671174 | 1329056 | . SalePrice 9500 | 14000 | 50000 | 16000 | 22000 | . MachineID 1126363 | 1194089 | 1473654 | 1327630 | 1336053 | . ModelID 8434 | 10150 | 4139 | 8591 | 4089 | . datasource 132 | 132 | 132 | 132 | 132 | . auctioneerID 18 | 99 | 99 | 99 | 99 | . YearMade 1974 | 1980 | 1978 | 1980 | 1984 | . MachineHoursCurrentMeter NaN | NaN | NaN | NaN | NaN | . UsageBand NaN | NaN | NaN | NaN | NaN | . saledate 1989-01-17 00:00:00 | 1989-01-31 00:00:00 | 1989-01-31 00:00:00 | 1989-01-31 00:00:00 | 1989-01-31 00:00:00 | . fiModelDesc TD20 | A66 | D7G | A62 | D3B | . fiBaseModel TD20 | A66 | D7 | A62 | D3 | . fiSecondaryDesc NaN | NaN | G | NaN | B | . fiModelSeries NaN | NaN | NaN | NaN | NaN | . fiModelDescriptor NaN | NaN | NaN | NaN | NaN | . ProductSize Medium | NaN | Large | NaN | NaN | . fiProductClassDesc Track Type Tractor, Dozer - 105.0 to 130.0 Hor... | Wheel Loader - 120.0 to 135.0 Horsepower | Track Type Tractor, Dozer - 190.0 to 260.0 Hor... | Wheel Loader - Unidentified | Track Type Tractor, Dozer - 20.0 to 75.0 Horse... | . state Texas | Florida | Florida | Florida | Florida | . ProductGroup TTT | WL | TTT | WL | TTT | . ProductGroupDesc Track Type Tractors | Wheel Loader | Track Type Tractors | Wheel Loader | Track Type Tractors | . Drive_System NaN | NaN | NaN | NaN | NaN | . Enclosure OROPS | OROPS | OROPS | EROPS | OROPS | . Forks NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Pad_Type NaN | NaN | NaN | NaN | NaN | . Ride_Control NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Stick NaN | NaN | NaN | NaN | NaN | . Transmission Direct Drive | NaN | Standard | NaN | Standard | . Turbocharged NaN | NaN | NaN | NaN | NaN | . Blade_Extension NaN | NaN | NaN | NaN | NaN | . Blade_Width NaN | NaN | NaN | NaN | NaN | . Enclosure_Type NaN | NaN | NaN | NaN | NaN | . Engine_Horsepower NaN | NaN | NaN | NaN | NaN | . Hydraulics 2 Valve | 2 Valve | 2 Valve | 2 Valve | 2 Valve | . Pushblock NaN | NaN | NaN | NaN | NaN | . Ripper None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Scarifier NaN | NaN | NaN | NaN | NaN | . Tip_Control NaN | NaN | NaN | NaN | NaN | . Tire_Size NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler_System NaN | NaN | NaN | NaN | NaN | . Grouser_Tracks NaN | NaN | NaN | NaN | NaN | . Hydraulics_Flow NaN | NaN | NaN | NaN | NaN | . Track_Type NaN | NaN | NaN | NaN | NaN | . Undercarriage_Pad_Width NaN | NaN | NaN | NaN | NaN | . Stick_Length NaN | NaN | NaN | NaN | NaN | . Thumb NaN | NaN | NaN | NaN | NaN | . Pattern_Changer NaN | NaN | NaN | NaN | NaN | . Grouser_Type NaN | NaN | NaN | NaN | NaN | . Backhoe_Mounting None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Blade_Type Straight | NaN | Straight | NaN | PAT | . Travel_Controls None or Unspecified | NaN | None or Unspecified | NaN | Lever | . Differential_Type NaN | Standard | NaN | Standard | NaN | . Steering_Controls NaN | Conventional | NaN | Conventional | NaN | . saleYear 1989 | 1989 | 1989 | 1989 | 1989 | . saleMonth 1 | 1 | 1 | 1 | 1 | . saleDay 17 | 31 | 31 | 31 | 31 | . saleDayOfWeek 1 | 1 | 1 | 1 | 1 | . saleDayOfYear 17 | 31 | 31 | 31 | 31 | . # Now we&#39;ve enriched our DataFrame with data time features, we can remove the &quot;saledate&quot; column. df_tmp.drop(&quot;saledate&quot;, axis=1, inplace=True) . df_tmp.saledate . - AttributeError Traceback (most recent call last) &lt;ipython-input-25-0b8254724953&gt; in &lt;module&gt; -&gt; 1 df_tmp.saledate ~ bulldozer-price-project env lib site-packages pandas core generic.py in __getattr__(self, name) 5272 if self._info_axis._can_hold_identifiers_and_holds_name(name): 5273 return self[name] -&gt; 5274 return object.__getattribute__(self, name) 5275 5276 def __setattr__(self, name: str, value) -&gt; None: AttributeError: &#39;DataFrame&#39; object has no attribute &#39;saledate&#39; . # Check the values of different columns df_tmp.state.value_counts() . Florida 67320 Texas 53110 California 29761 Washington 16222 Georgia 14633 Maryland 13322 Mississippi 13240 Ohio 12369 Illinois 11540 Colorado 11529 New Jersey 11156 North Carolina 10636 Tennessee 10298 Alabama 10292 Pennsylvania 10234 South Carolina 9951 Arizona 9364 New York 8639 Connecticut 8276 Minnesota 7885 Missouri 7178 Nevada 6932 Louisiana 6627 Kentucky 5351 Maine 5096 Indiana 4124 Arkansas 3933 New Mexico 3631 Utah 3046 Unspecified 2801 Wisconsin 2745 New Hampshire 2738 Virginia 2353 Idaho 2025 Oregon 1911 Michigan 1831 Wyoming 1672 Montana 1336 Iowa 1336 Oklahoma 1326 Nebraska 866 West Virginia 840 Kansas 667 Delaware 510 North Dakota 480 Alaska 430 Massachusetts 347 Vermont 300 South Dakota 244 Hawaii 118 Rhode Island 83 Puerto Rico 42 Washington DC 2 Name: state, dtype: int64 . 5. Modelling . We&#39;ve done enough EDA (we could always do more), but let&#39;s start to do some model-driven EDA. . # Let&#39;s build a machine learning model. (Regression) from sklearn.ensemble import RandomForestRegressor model = RandomForestRegressor(n_jobs=-1, random_state=42) model.fit(df_tmp.drop(&quot;SalePrice&quot;, axis=1), df_tmp[&quot;SalePrice&quot;]) . - ValueError Traceback (most recent call last) &lt;ipython-input-28-c5024f945ee9&gt; in &lt;module&gt; 5 random_state=42) 6 -&gt; 7 model.fit(df_tmp.drop(&#34;SalePrice&#34;, axis=1), df_tmp[&#34;SalePrice&#34;]) ~ bulldozer-price-project env lib site-packages sklearn ensemble _forest.py in fit(self, X, y, sample_weight) 293 &#34;&#34;&#34; 294 # Validate or convert input data --&gt; 295 X = check_array(X, accept_sparse=&#34;csc&#34;, dtype=DTYPE) 296 y = check_array(y, accept_sparse=&#39;csc&#39;, ensure_2d=False, dtype=None) 297 if sample_weight is not None: ~ bulldozer-price-project env lib site-packages sklearn utils validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, warn_on_dtype, estimator) 529 array = array.astype(dtype, casting=&#34;unsafe&#34;, copy=False) 530 else: --&gt; 531 array = np.asarray(array, order=order, dtype=dtype) 532 except ComplexWarning: 533 raise ValueError(&#34;Complex data not supported n&#34; ~ bulldozer-price-project env lib site-packages numpy core _asarray.py in asarray(a, dtype, order) 83 84 &#34;&#34;&#34; &gt; 85 return array(a, dtype, copy=False, order=order) 86 87 ValueError: could not convert string to float: &#39;Low&#39; . df_tmp.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 412698 entries, 205615 to 409203 Data columns (total 57 columns): # Column Non-Null Count Dtype -- -- 0 SalesID 412698 non-null int64 1 SalePrice 412698 non-null float64 2 MachineID 412698 non-null int64 3 ModelID 412698 non-null int64 4 datasource 412698 non-null int64 5 auctioneerID 392562 non-null float64 6 YearMade 412698 non-null int64 7 MachineHoursCurrentMeter 147504 non-null float64 8 UsageBand 73670 non-null object 9 fiModelDesc 412698 non-null object 10 fiBaseModel 412698 non-null object 11 fiSecondaryDesc 271971 non-null object 12 fiModelSeries 58667 non-null object 13 fiModelDescriptor 74816 non-null object 14 ProductSize 196093 non-null object 15 fiProductClassDesc 412698 non-null object 16 state 412698 non-null object 17 ProductGroup 412698 non-null object 18 ProductGroupDesc 412698 non-null object 19 Drive_System 107087 non-null object 20 Enclosure 412364 non-null object 21 Forks 197715 non-null object 22 Pad_Type 81096 non-null object 23 Ride_Control 152728 non-null object 24 Stick 81096 non-null object 25 Transmission 188007 non-null object 26 Turbocharged 81096 non-null object 27 Blade_Extension 25983 non-null object 28 Blade_Width 25983 non-null object 29 Enclosure_Type 25983 non-null object 30 Engine_Horsepower 25983 non-null object 31 Hydraulics 330133 non-null object 32 Pushblock 25983 non-null object 33 Ripper 106945 non-null object 34 Scarifier 25994 non-null object 35 Tip_Control 25983 non-null object 36 Tire_Size 97638 non-null object 37 Coupler 220679 non-null object 38 Coupler_System 44974 non-null object 39 Grouser_Tracks 44875 non-null object 40 Hydraulics_Flow 44875 non-null object 41 Track_Type 102193 non-null object 42 Undercarriage_Pad_Width 102916 non-null object 43 Stick_Length 102261 non-null object 44 Thumb 102332 non-null object 45 Pattern_Changer 102261 non-null object 46 Grouser_Type 102193 non-null object 47 Backhoe_Mounting 80712 non-null object 48 Blade_Type 81875 non-null object 49 Travel_Controls 81877 non-null object 50 Differential_Type 71564 non-null object 51 Steering_Controls 71522 non-null object 52 saleYear 412698 non-null int64 53 saleMonth 412698 non-null int64 54 saleDay 412698 non-null int64 55 saleDayOfWeek 412698 non-null int64 56 saleDayOfYear 412698 non-null int64 dtypes: float64(3), int64(10), object(44) memory usage: 182.6+ MB . df_tmp.isna().sum() . SalesID 0 SalePrice 0 MachineID 0 ModelID 0 datasource 0 auctioneerID 20136 YearMade 0 MachineHoursCurrentMeter 265194 UsageBand 339028 fiModelDesc 0 fiBaseModel 0 fiSecondaryDesc 140727 fiModelSeries 354031 fiModelDescriptor 337882 ProductSize 216605 fiProductClassDesc 0 state 0 ProductGroup 0 ProductGroupDesc 0 Drive_System 305611 Enclosure 334 Forks 214983 Pad_Type 331602 Ride_Control 259970 Stick 331602 Transmission 224691 Turbocharged 331602 Blade_Extension 386715 Blade_Width 386715 Enclosure_Type 386715 Engine_Horsepower 386715 Hydraulics 82565 Pushblock 386715 Ripper 305753 Scarifier 386704 Tip_Control 386715 Tire_Size 315060 Coupler 192019 Coupler_System 367724 Grouser_Tracks 367823 Hydraulics_Flow 367823 Track_Type 310505 Undercarriage_Pad_Width 309782 Stick_Length 310437 Thumb 310366 Pattern_Changer 310437 Grouser_Type 310505 Backhoe_Mounting 331986 Blade_Type 330823 Travel_Controls 330821 Differential_Type 341134 Steering_Controls 341176 saleYear 0 saleMonth 0 saleDay 0 saleDayOfWeek 0 saleDayOfYear 0 dtype: int64 . Convert strings to categories . One way we can turn all of our data into numbers is by converting them into pandas categories. . We can check the different datatypes compatible with pandas here: https://pandas.pydata.org/pandas-docs/stable/reference/general_utility_functions.html#data-types-related-functionality . df_tmp.head().T . 205615 274835 141296 212552 62755 . SalesID 1646770 | 1821514 | 1505138 | 1671174 | 1329056 | . SalePrice 9500 | 14000 | 50000 | 16000 | 22000 | . MachineID 1126363 | 1194089 | 1473654 | 1327630 | 1336053 | . ModelID 8434 | 10150 | 4139 | 8591 | 4089 | . datasource 132 | 132 | 132 | 132 | 132 | . auctioneerID 18 | 99 | 99 | 99 | 99 | . YearMade 1974 | 1980 | 1978 | 1980 | 1984 | . MachineHoursCurrentMeter NaN | NaN | NaN | NaN | NaN | . UsageBand NaN | NaN | NaN | NaN | NaN | . fiModelDesc TD20 | A66 | D7G | A62 | D3B | . fiBaseModel TD20 | A66 | D7 | A62 | D3 | . fiSecondaryDesc NaN | NaN | G | NaN | B | . fiModelSeries NaN | NaN | NaN | NaN | NaN | . fiModelDescriptor NaN | NaN | NaN | NaN | NaN | . ProductSize Medium | NaN | Large | NaN | NaN | . fiProductClassDesc Track Type Tractor, Dozer - 105.0 to 130.0 Hor... | Wheel Loader - 120.0 to 135.0 Horsepower | Track Type Tractor, Dozer - 190.0 to 260.0 Hor... | Wheel Loader - Unidentified | Track Type Tractor, Dozer - 20.0 to 75.0 Horse... | . state Texas | Florida | Florida | Florida | Florida | . ProductGroup TTT | WL | TTT | WL | TTT | . ProductGroupDesc Track Type Tractors | Wheel Loader | Track Type Tractors | Wheel Loader | Track Type Tractors | . Drive_System NaN | NaN | NaN | NaN | NaN | . Enclosure OROPS | OROPS | OROPS | EROPS | OROPS | . Forks NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Pad_Type NaN | NaN | NaN | NaN | NaN | . Ride_Control NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Stick NaN | NaN | NaN | NaN | NaN | . Transmission Direct Drive | NaN | Standard | NaN | Standard | . Turbocharged NaN | NaN | NaN | NaN | NaN | . Blade_Extension NaN | NaN | NaN | NaN | NaN | . Blade_Width NaN | NaN | NaN | NaN | NaN | . Enclosure_Type NaN | NaN | NaN | NaN | NaN | . Engine_Horsepower NaN | NaN | NaN | NaN | NaN | . Hydraulics 2 Valve | 2 Valve | 2 Valve | 2 Valve | 2 Valve | . Pushblock NaN | NaN | NaN | NaN | NaN | . Ripper None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Scarifier NaN | NaN | NaN | NaN | NaN | . Tip_Control NaN | NaN | NaN | NaN | NaN | . Tire_Size NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler_System NaN | NaN | NaN | NaN | NaN | . Grouser_Tracks NaN | NaN | NaN | NaN | NaN | . Hydraulics_Flow NaN | NaN | NaN | NaN | NaN | . Track_Type NaN | NaN | NaN | NaN | NaN | . Undercarriage_Pad_Width NaN | NaN | NaN | NaN | NaN | . Stick_Length NaN | NaN | NaN | NaN | NaN | . Thumb NaN | NaN | NaN | NaN | NaN | . Pattern_Changer NaN | NaN | NaN | NaN | NaN | . Grouser_Type NaN | NaN | NaN | NaN | NaN | . Backhoe_Mounting None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Blade_Type Straight | NaN | Straight | NaN | PAT | . Travel_Controls None or Unspecified | NaN | None or Unspecified | NaN | Lever | . Differential_Type NaN | Standard | NaN | Standard | NaN | . Steering_Controls NaN | Conventional | NaN | Conventional | NaN | . saleYear 1989 | 1989 | 1989 | 1989 | 1989 | . saleMonth 1 | 1 | 1 | 1 | 1 | . saleDay 17 | 31 | 31 | 31 | 31 | . saleDayOfWeek 1 | 1 | 1 | 1 | 1 | . saleDayOfYear 17 | 31 | 31 | 31 | 31 | . pd.api.types.is_string_dtype(df_tmp[&quot;UsageBand&quot;]) . True . df_tmp.items() . &lt;generator object DataFrame.items at 0x0000000021E9F660&gt; . # Find the columns which contain strings for label, content in df_tmp.items(): if pd.api.types.is_string_dtype(content): print(label) . UsageBand fiModelDesc fiBaseModel fiSecondaryDesc fiModelSeries fiModelDescriptor ProductSize fiProductClassDesc state ProductGroup ProductGroupDesc Drive_System Enclosure Forks Pad_Type Ride_Control Stick Transmission Turbocharged Blade_Extension Blade_Width Enclosure_Type Engine_Horsepower Hydraulics Pushblock Ripper Scarifier Tip_Control Tire_Size Coupler Coupler_System Grouser_Tracks Hydraulics_Flow Track_Type Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls . # If you&#39;re wondering what df.items() does, here&#39;s an example random_dict = {&quot;key1&quot;: &quot;Hello,&quot;, &quot;key2&quot;: &quot;world!&quot;} for key, value in random_dict.items(): print(f&quot;this is a key: {key}&quot;, f&quot;this is a value: {value}&quot;) . this is a key: key1 this is a value: Hello, this is a key: key2 this is a value: world! . # This will turn all of the string values into category values for label, content in df_tmp.items(): if pd.api.types.is_string_dtype(content): df_tmp[label] = content.astype(&quot;category&quot;).cat.as_ordered() . df_tmp.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 412698 entries, 205615 to 409203 Data columns (total 57 columns): # Column Non-Null Count Dtype -- -- 0 SalesID 412698 non-null int64 1 SalePrice 412698 non-null float64 2 MachineID 412698 non-null int64 3 ModelID 412698 non-null int64 4 datasource 412698 non-null int64 5 auctioneerID 392562 non-null float64 6 YearMade 412698 non-null int64 7 MachineHoursCurrentMeter 147504 non-null float64 8 UsageBand 73670 non-null category 9 fiModelDesc 412698 non-null category 10 fiBaseModel 412698 non-null category 11 fiSecondaryDesc 271971 non-null category 12 fiModelSeries 58667 non-null category 13 fiModelDescriptor 74816 non-null category 14 ProductSize 196093 non-null category 15 fiProductClassDesc 412698 non-null category 16 state 412698 non-null category 17 ProductGroup 412698 non-null category 18 ProductGroupDesc 412698 non-null category 19 Drive_System 107087 non-null category 20 Enclosure 412364 non-null category 21 Forks 197715 non-null category 22 Pad_Type 81096 non-null category 23 Ride_Control 152728 non-null category 24 Stick 81096 non-null category 25 Transmission 188007 non-null category 26 Turbocharged 81096 non-null category 27 Blade_Extension 25983 non-null category 28 Blade_Width 25983 non-null category 29 Enclosure_Type 25983 non-null category 30 Engine_Horsepower 25983 non-null category 31 Hydraulics 330133 non-null category 32 Pushblock 25983 non-null category 33 Ripper 106945 non-null category 34 Scarifier 25994 non-null category 35 Tip_Control 25983 non-null category 36 Tire_Size 97638 non-null category 37 Coupler 220679 non-null category 38 Coupler_System 44974 non-null category 39 Grouser_Tracks 44875 non-null category 40 Hydraulics_Flow 44875 non-null category 41 Track_Type 102193 non-null category 42 Undercarriage_Pad_Width 102916 non-null category 43 Stick_Length 102261 non-null category 44 Thumb 102332 non-null category 45 Pattern_Changer 102261 non-null category 46 Grouser_Type 102193 non-null category 47 Backhoe_Mounting 80712 non-null category 48 Blade_Type 81875 non-null category 49 Travel_Controls 81877 non-null category 50 Differential_Type 71564 non-null category 51 Steering_Controls 71522 non-null category 52 saleYear 412698 non-null int64 53 saleMonth 412698 non-null int64 54 saleDay 412698 non-null int64 55 saleDayOfWeek 412698 non-null int64 56 saleDayOfYear 412698 non-null int64 dtypes: category(44), float64(3), int64(10) memory usage: 63.3 MB . df_tmp.state.cat.categories . Index([&#39;Alabama&#39;, &#39;Alaska&#39;, &#39;Arizona&#39;, &#39;Arkansas&#39;, &#39;California&#39;, &#39;Colorado&#39;, &#39;Connecticut&#39;, &#39;Delaware&#39;, &#39;Florida&#39;, &#39;Georgia&#39;, &#39;Hawaii&#39;, &#39;Idaho&#39;, &#39;Illinois&#39;, &#39;Indiana&#39;, &#39;Iowa&#39;, &#39;Kansas&#39;, &#39;Kentucky&#39;, &#39;Louisiana&#39;, &#39;Maine&#39;, &#39;Maryland&#39;, &#39;Massachusetts&#39;, &#39;Michigan&#39;, &#39;Minnesota&#39;, &#39;Mississippi&#39;, &#39;Missouri&#39;, &#39;Montana&#39;, &#39;Nebraska&#39;, &#39;Nevada&#39;, &#39;New Hampshire&#39;, &#39;New Jersey&#39;, &#39;New Mexico&#39;, &#39;New York&#39;, &#39;North Carolina&#39;, &#39;North Dakota&#39;, &#39;Ohio&#39;, &#39;Oklahoma&#39;, &#39;Oregon&#39;, &#39;Pennsylvania&#39;, &#39;Puerto Rico&#39;, &#39;Rhode Island&#39;, &#39;South Carolina&#39;, &#39;South Dakota&#39;, &#39;Tennessee&#39;, &#39;Texas&#39;, &#39;Unspecified&#39;, &#39;Utah&#39;, &#39;Vermont&#39;, &#39;Virginia&#39;, &#39;Washington&#39;, &#39;Washington DC&#39;, &#39;West Virginia&#39;, &#39;Wisconsin&#39;, &#39;Wyoming&#39;], dtype=&#39;object&#39;) . df_tmp.state.cat . &lt;pandas.core.arrays.categorical.CategoricalAccessor object at 0x000000000C211100&gt; . df_tmp.state.cat.codes . 205615 43 274835 8 141296 8 212552 8 62755 8 .. 410879 4 412476 4 411927 4 407124 4 409203 4 Length: 412698, dtype: int8 . Thanks to pandas Categories, we now have a way to access all of our data in the form of numbers. . But we still have a bunch of missing data... . # Check missing data df_tmp.isnull().sum()/len(df_tmp) . SalesID 0.000000 SalePrice 0.000000 MachineID 0.000000 ModelID 0.000000 datasource 0.000000 auctioneerID 0.048791 YearMade 0.000000 MachineHoursCurrentMeter 0.642586 UsageBand 0.821492 fiModelDesc 0.000000 fiBaseModel 0.000000 fiSecondaryDesc 0.340993 fiModelSeries 0.857845 fiModelDescriptor 0.818715 ProductSize 0.524851 fiProductClassDesc 0.000000 state 0.000000 ProductGroup 0.000000 ProductGroupDesc 0.000000 Drive_System 0.740520 Enclosure 0.000809 Forks 0.520921 Pad_Type 0.803498 Ride_Control 0.629928 Stick 0.803498 Transmission 0.544444 Turbocharged 0.803498 Blade_Extension 0.937041 Blade_Width 0.937041 Enclosure_Type 0.937041 Engine_Horsepower 0.937041 Hydraulics 0.200062 Pushblock 0.937041 Ripper 0.740864 Scarifier 0.937014 Tip_Control 0.937041 Tire_Size 0.763415 Coupler 0.465277 Coupler_System 0.891024 Grouser_Tracks 0.891264 Hydraulics_Flow 0.891264 Track_Type 0.752378 Undercarriage_Pad_Width 0.750626 Stick_Length 0.752213 Thumb 0.752041 Pattern_Changer 0.752213 Grouser_Type 0.752378 Backhoe_Mounting 0.804428 Blade_Type 0.801610 Travel_Controls 0.801606 Differential_Type 0.826595 Steering_Controls 0.826697 saleYear 0.000000 saleMonth 0.000000 saleDay 0.000000 saleDayOfWeek 0.000000 saleDayOfYear 0.000000 dtype: float64 . Save preprocessed data . # Import preprocessed data df_tmp = pd.read_csv(&quot;data/train_tmp.csv&quot;, low_memory=False) df_tmp.head().T . 0 1 2 3 4 . SalesID 1646770 | 1821514 | 1505138 | 1671174 | 1329056 | . SalePrice 9500 | 14000 | 50000 | 16000 | 22000 | . MachineID 1126363 | 1194089 | 1473654 | 1327630 | 1336053 | . ModelID 8434 | 10150 | 4139 | 8591 | 4089 | . datasource 132 | 132 | 132 | 132 | 132 | . auctioneerID 18 | 99 | 99 | 99 | 99 | . YearMade 1974 | 1980 | 1978 | 1980 | 1984 | . MachineHoursCurrentMeter NaN | NaN | NaN | NaN | NaN | . UsageBand NaN | NaN | NaN | NaN | NaN | . fiModelDesc TD20 | A66 | D7G | A62 | D3B | . fiBaseModel TD20 | A66 | D7 | A62 | D3 | . fiSecondaryDesc NaN | NaN | G | NaN | B | . fiModelSeries NaN | NaN | NaN | NaN | NaN | . fiModelDescriptor NaN | NaN | NaN | NaN | NaN | . ProductSize Medium | NaN | Large | NaN | NaN | . fiProductClassDesc Track Type Tractor, Dozer - 105.0 to 130.0 Hor... | Wheel Loader - 120.0 to 135.0 Horsepower | Track Type Tractor, Dozer - 190.0 to 260.0 Hor... | Wheel Loader - Unidentified | Track Type Tractor, Dozer - 20.0 to 75.0 Horse... | . state Texas | Florida | Florida | Florida | Florida | . ProductGroup TTT | WL | TTT | WL | TTT | . ProductGroupDesc Track Type Tractors | Wheel Loader | Track Type Tractors | Wheel Loader | Track Type Tractors | . Drive_System NaN | NaN | NaN | NaN | NaN | . Enclosure OROPS | OROPS | OROPS | EROPS | OROPS | . Forks NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Pad_Type NaN | NaN | NaN | NaN | NaN | . Ride_Control NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Stick NaN | NaN | NaN | NaN | NaN | . Transmission Direct Drive | NaN | Standard | NaN | Standard | . Turbocharged NaN | NaN | NaN | NaN | NaN | . Blade_Extension NaN | NaN | NaN | NaN | NaN | . Blade_Width NaN | NaN | NaN | NaN | NaN | . Enclosure_Type NaN | NaN | NaN | NaN | NaN | . Engine_Horsepower NaN | NaN | NaN | NaN | NaN | . Hydraulics 2 Valve | 2 Valve | 2 Valve | 2 Valve | 2 Valve | . Pushblock NaN | NaN | NaN | NaN | NaN | . Ripper None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Scarifier NaN | NaN | NaN | NaN | NaN | . Tip_Control NaN | NaN | NaN | NaN | NaN | . Tire_Size NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler NaN | None or Unspecified | NaN | None or Unspecified | NaN | . Coupler_System NaN | NaN | NaN | NaN | NaN | . Grouser_Tracks NaN | NaN | NaN | NaN | NaN | . Hydraulics_Flow NaN | NaN | NaN | NaN | NaN | . Track_Type NaN | NaN | NaN | NaN | NaN | . Undercarriage_Pad_Width NaN | NaN | NaN | NaN | NaN | . Stick_Length NaN | NaN | NaN | NaN | NaN | . Thumb NaN | NaN | NaN | NaN | NaN | . Pattern_Changer NaN | NaN | NaN | NaN | NaN | . Grouser_Type NaN | NaN | NaN | NaN | NaN | . Backhoe_Mounting None or Unspecified | NaN | None or Unspecified | NaN | None or Unspecified | . Blade_Type Straight | NaN | Straight | NaN | PAT | . Travel_Controls None or Unspecified | NaN | None or Unspecified | NaN | Lever | . Differential_Type NaN | Standard | NaN | Standard | NaN | . Steering_Controls NaN | Conventional | NaN | Conventional | NaN | . saleYear 1989 | 1989 | 1989 | 1989 | 1989 | . saleMonth 1 | 1 | 1 | 1 | 1 | . saleDay 17 | 31 | 31 | 31 | 31 | . saleDayOfWeek 1 | 1 | 1 | 1 | 1 | . saleDayOfYear 17 | 31 | 31 | 31 | 31 | . df_tmp.isnull().sum() . SalesID 0 SalePrice 0 MachineID 0 ModelID 0 datasource 0 auctioneerID 20136 YearMade 0 MachineHoursCurrentMeter 265194 UsageBand 339028 fiModelDesc 0 fiBaseModel 0 fiSecondaryDesc 140727 fiModelSeries 354031 fiModelDescriptor 337882 ProductSize 216605 fiProductClassDesc 0 state 0 ProductGroup 0 ProductGroupDesc 0 Drive_System 305611 Enclosure 334 Forks 214983 Pad_Type 331602 Ride_Control 259970 Stick 331602 Transmission 224691 Turbocharged 331602 Blade_Extension 386715 Blade_Width 386715 Enclosure_Type 386715 Engine_Horsepower 386715 Hydraulics 82565 Pushblock 386715 Ripper 305753 Scarifier 386704 Tip_Control 386715 Tire_Size 315060 Coupler 192019 Coupler_System 367724 Grouser_Tracks 367823 Hydraulics_Flow 367823 Track_Type 310505 Undercarriage_Pad_Width 309782 Stick_Length 310437 Thumb 310366 Pattern_Changer 310437 Grouser_Type 310505 Backhoe_Mounting 331986 Blade_Type 330823 Travel_Controls 330821 Differential_Type 341134 Steering_Controls 341176 saleYear 0 saleMonth 0 saleDay 0 saleDayOfWeek 0 saleDayOfYear 0 dtype: int64 . Fill missing values . Fill numerical missing values first . for label, content in df_tmp.items(): if pd.api.types.is_numeric_dtype(content): print(label) . SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter saleYear saleMonth saleDay saleDayOfWeek saleDayOfYear . # Check for which numeric colums have null values for label, content in df_tmp.items(): if pd.api.types.is_numeric_dtype(content): if pd.isnull(content).sum(): print(label) . auctioneerID MachineHoursCurrentMeter . Looks like these two numerical columns have null values. . Let&#39;s fill them with the median. . # Fill numeric rows with the median for label, content in df_tmp.items(): if pd.api.types.is_numeric_dtype(content): if pd.isnull(content).sum(): # Add a binary column which tells us if the data was missing df_tmp[label+&quot;_is_missing&quot;] = pd.isnull(content) # Fill missing numeric values with median df_tmp[label] = content.fillna(content.median()) . After this, the new column will be True if it was null, and False if it was filled. . # Why median is more robust than mean hundreds = np.full((1000,), 100) hundreds_billion = np.append(hundreds, 1000000000) np.mean(hundreds), np.mean(hundreds_billion), np.median(hundreds), np.median(hundreds_billion) . (100.0, 999100.8991008991, 100.0, 100.0) . pd.DataFrame(hundreds).plot.hist(); . pd.DataFrame(hundreds_billion).plot.hist(); . # Check if there&#39;s any null numeric values: for label, content in df_tmp.items(): if pd.api.types.is_numeric_dtype(content): if pd.isnull(content).sum(): print(label) . None? Perfect! That&#39;s what we&#39;ve expected. . # Check to see how many examples were missing df_tmp.auctioneerID_is_missing.value_counts() . False 392562 True 20136 Name: auctioneerID_is_missing, dtype: int64 . 20136 True&#39;s means there were 20136 missing values. . Remember before the auctioneerID and MachineHoursCurrentMeter had missing values? . Now they should all be filled. . df_tmp.isna().sum() . SalesID 0 SalePrice 0 MachineID 0 ModelID 0 datasource 0 auctioneerID 0 YearMade 0 MachineHoursCurrentMeter 0 UsageBand 339028 fiModelDesc 0 fiBaseModel 0 fiSecondaryDesc 140727 fiModelSeries 354031 fiModelDescriptor 337882 ProductSize 216605 fiProductClassDesc 0 state 0 ProductGroup 0 ProductGroupDesc 0 Drive_System 305611 Enclosure 334 Forks 214983 Pad_Type 331602 Ride_Control 259970 Stick 331602 Transmission 224691 Turbocharged 331602 Blade_Extension 386715 Blade_Width 386715 Enclosure_Type 386715 Engine_Horsepower 386715 Hydraulics 82565 Pushblock 386715 Ripper 305753 Scarifier 386704 Tip_Control 386715 Tire_Size 315060 Coupler 192019 Coupler_System 367724 Grouser_Tracks 367823 Hydraulics_Flow 367823 Track_Type 310505 Undercarriage_Pad_Width 309782 Stick_Length 310437 Thumb 310366 Pattern_Changer 310437 Grouser_Type 310505 Backhoe_Mounting 331986 Blade_Type 330823 Travel_Controls 330821 Differential_Type 341134 Steering_Controls 341176 saleYear 0 saleMonth 0 saleDay 0 saleDayOfWeek 0 saleDayOfYear 0 auctioneerID_is_missing 0 MachineHoursCurrentMeter_is_missing 0 dtype: int64 . Look! The auctioneerID and MachineHoursCurrentMeter now don&#39;t have missing values! . # Check for columns which aren&#39;t numeric for label, content in df_tmp.items(): if not pd.api.types.is_numeric_dtype(content): print(label) . UsageBand fiModelDesc fiBaseModel fiSecondaryDesc fiModelSeries fiModelDescriptor ProductSize fiProductClassDesc state ProductGroup ProductGroupDesc Drive_System Enclosure Forks Pad_Type Ride_Control Stick Transmission Turbocharged Blade_Extension Blade_Width Enclosure_Type Engine_Horsepower Hydraulics Pushblock Ripper Scarifier Tip_Control Tire_Size Coupler Coupler_System Grouser_Tracks Hydraulics_Flow Track_Type Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls . # Turn categorical variables into numbers and fill missing values for label, content in df_tmp.items(): if not pd.api.types.is_numeric_dtype(content): # Add binary column to indicate whether sample had missing value df_tmp[label+&quot;_is_missing&quot;] = pd.isnull(content) # Turn categories into numbers and add +1 df_tmp[label] = pd.Categorical(content).codes + 1 . df_tmp.head().T . 0 1 2 3 4 . SalesID 1646770 | 1821514 | 1505138 | 1671174 | 1329056 | . SalePrice 9500 | 14000 | 50000 | 16000 | 22000 | . MachineID 1126363 | 1194089 | 1473654 | 1327630 | 1336053 | . ModelID 8434 | 10150 | 4139 | 8591 | 4089 | . datasource 132 | 132 | 132 | 132 | 132 | . ... ... | ... | ... | ... | ... | . Backhoe_Mounting_is_missing False | True | False | True | False | . Blade_Type_is_missing False | True | False | True | False | . Travel_Controls_is_missing False | True | False | True | False | . Differential_Type_is_missing True | False | True | False | True | . Steering_Controls_is_missing True | False | True | False | True | . 103 rows × 5 columns . df_tmp.isna().sum() . SalesID 0 SalePrice 0 MachineID 0 ModelID 0 datasource 0 .. Backhoe_Mounting_is_missing 0 Blade_Type_is_missing 0 Travel_Controls_is_missing 0 Differential_Type_is_missing 0 Steering_Controls_is_missing 0 Length: 103, dtype: int64 . Now we have no missing values and all values are numerical... . Based on what you know about machine learning, what can we do now? . We should be able to build a machine learning model. . df_tmp.head() . SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Undercarriage_Pad_Width_is_missing Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing . 0 1646770 | 9500.0 | 1126363 | 8434 | 132 | 18.0 | 1974 | 0.0 | 0 | 4593 | ... | True | True | True | True | True | False | False | False | True | True | . 1 1821514 | 14000.0 | 1194089 | 10150 | 132 | 99.0 | 1980 | 0.0 | 0 | 1820 | ... | True | True | True | True | True | True | True | True | False | False | . 2 1505138 | 50000.0 | 1473654 | 4139 | 132 | 99.0 | 1978 | 0.0 | 0 | 2348 | ... | True | True | True | True | True | False | False | False | True | True | . 3 1671174 | 16000.0 | 1327630 | 8591 | 132 | 99.0 | 1980 | 0.0 | 0 | 1819 | ... | True | True | True | True | True | True | True | True | False | False | . 4 1329056 | 22000.0 | 1336053 | 4089 | 132 | 99.0 | 1984 | 0.0 | 0 | 2119 | ... | True | True | True | True | True | False | False | False | True | True | . 5 rows × 103 columns . %% is a jupyter magic function. . %%time calculates the time the current cell takes. . len(df_tmp) . 412698 . %%time # Instantiate model from sklearn.ensemble import RandomForestRegressor model = RandomForestRegressor(n_jobs=-1, random_state=42) # Fit the model model.fit(df_tmp.drop(&quot;SalePrice&quot;, axis=1), df_tmp[&quot;SalePrice&quot;]) . Wall time: 7min 52s . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=-1, oob_score=False, random_state=42, verbose=0, warm_start=False) . # Score the model model.score(df_tmp.drop(&quot;SalePrice&quot;, axis=1), df_tmp[&quot;SalePrice&quot;]) . 0.9875468079970563 . Question: Why doesn&#39;t the above metric hold water? (why isn&#39;t the metric reliable) . Splitting data into train/validation sets . df_tmp.head() . SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Undercarriage_Pad_Width_is_missing Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing . 0 1646770 | 9500.0 | 1126363 | 8434 | 132 | 18.0 | 1974 | 0.0 | 0 | 4593 | ... | True | True | True | True | True | False | False | False | True | True | . 1 1821514 | 14000.0 | 1194089 | 10150 | 132 | 99.0 | 1980 | 0.0 | 0 | 1820 | ... | True | True | True | True | True | True | True | True | False | False | . 2 1505138 | 50000.0 | 1473654 | 4139 | 132 | 99.0 | 1978 | 0.0 | 0 | 2348 | ... | True | True | True | True | True | False | False | False | True | True | . 3 1671174 | 16000.0 | 1327630 | 8591 | 132 | 99.0 | 1980 | 0.0 | 0 | 1819 | ... | True | True | True | True | True | True | True | True | False | False | . 4 1329056 | 22000.0 | 1336053 | 4089 | 132 | 99.0 | 1984 | 0.0 | 0 | 2119 | ... | True | True | True | True | True | False | False | False | True | True | . 5 rows × 103 columns . df_tmp.saleYear . 0 1989 1 1989 2 1989 3 1989 4 1989 ... 412693 2012 412694 2012 412695 2012 412696 2012 412697 2012 Name: saleYear, Length: 412698, dtype: int64 . df_tmp.saleYear.value_counts() . 2009 43849 2008 39767 2011 35197 2010 33390 2007 32208 2006 21685 2005 20463 2004 19879 2001 17594 2000 17415 2002 17246 2003 15254 1998 13046 1999 12793 2012 11573 1997 9785 1996 8829 1995 8530 1994 7929 1993 6303 1992 5519 1991 5109 1989 4806 1990 4529 Name: saleYear, dtype: int64 . # Split data into training and validation df_val = df_tmp[df_tmp.saleYear == 2012] df_train = df_tmp[df_tmp.saleYear != 2012] len(df_val), len(df_train) . (11573, 401125) . # Split data into X &amp; y X_train, y_train = df_train.drop(&quot;SalePrice&quot;, axis=1), df_train.SalePrice X_valid, y_valid = df_val.drop(&quot;SalePrice&quot;, axis=1), df_val.SalePrice X_train.shape, y_train.shape, X_valid.shape, y_valid.shape . ((401125, 102), (401125,), (11573, 102), (11573,)) . Building an evaluation function . # Create evaluation function (the competition uses RMSLE) from sklearn.metrics import mean_squared_log_error, mean_absolute_error, r2_score def rmsle(y_test, y_preds): &quot;&quot;&quot; Caculates root mean squared log error between predictions and true labels. &quot;&quot;&quot; return np.sqrt(mean_squared_log_error(y_test, y_preds)) # Create function to evaluate model on a few different levels def show_scores(model): train_preds = model.predict(X_train) val_preds = model.predict(X_valid) scores = {&quot;Train MAE&quot;: mean_absolute_error(y_train, train_preds), &quot;Valid MAE&quot;: mean_absolute_error(y_valid, val_preds), &quot;Training RMSLE&quot;: rmsle(y_train, train_preds), &quot;Valid RMSLE&quot;: rmsle(y_valid, val_preds), &quot;Training R^2&quot;: r2_score(y_train, train_preds), &quot;Valid R^2&quot;: r2_score(y_valid, val_preds)} return scores . Testing our model on a subset (to tune the hyperparameters) . # # This takes far too long ... for experimenting # %%time # model = RandomForestRegressor(n_jobs=-1, # random_state=42) # model.fit(X_train, y_train) . # Change max_samples value model = RandomForestRegressor(n_jobs=-1, random_state=42, max_samples=10000) model . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=10000, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=-1, oob_score=False, random_state=42, verbose=0, warm_start=False) . %%time # Cutting down on the max number of samples each estimator can see improves training time model.fit(X_train, y_train) . Wall time: 17.8 s . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=10000, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=-1, oob_score=False, random_state=42, verbose=0, warm_start=False) . show_scores(model) . {&#39;Train MAE&#39;: 5561.2988092240585, &#39;Valid MAE&#39;: 7177.26365505919, &#39;Training RMSLE&#39;: 0.257745378256977, &#39;Valid RMSLE&#39;: 0.29362638671089003, &#39;Training R^2&#39;: 0.8606658995199189, &#39;Valid R^2&#39;: 0.8320374995090507} . Hyperparamter tuning with RandomizedSearchCV . %%time from sklearn.model_selection import RandomizedSearchCV # Different RandomForestRegressor hyperparameters rf_grid = {&quot;n_estimators&quot;: np.arange(10, 100, 10), &quot;max_depth&quot;: [None, 3, 5, 10], &quot;min_samples_split&quot;: np.arange(2, 20, 2), &quot;min_samples_leaf&quot;: np.arange(1, 20, 2), &quot;max_features&quot;: [0.5, 1, &quot;sqrt&quot;, &quot;auto&quot;], &quot;max_samples&quot;: [10000]} # Instantiate RadomizedSearchCV model rs_model = RandomizedSearchCV(RandomForestRegressor(n_jobs=-1, random_state=42), param_distributions=rf_grid, n_iter=2, cv=5, verbose=True) # Fit the RandomizedSearchCV model rs_model.fit(X_train, y_train) . Fitting 5 folds for each of 2 candidates, totalling 10 fits . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. [Parallel(n_jobs=1)]: Done 10 out of 10 | elapsed: 1.3min finished . Wall time: 1min 24s . RandomizedSearchCV(cv=5, error_score=nan, estimator=RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=-1, oob_score=False,... param_distributions={&#39;max_depth&#39;: [None, 3, 5, 10], &#39;max_features&#39;: [0.5, 1, &#39;sqrt&#39;, &#39;auto&#39;], &#39;max_samples&#39;: [10000], &#39;min_samples_leaf&#39;: array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]), &#39;min_samples_split&#39;: array([ 2, 4, 6, 8, 10, 12, 14, 16, 18]), &#39;n_estimators&#39;: array([10, 20, 30, 40, 50, 60, 70, 80, 90])}, pre_dispatch=&#39;2*n_jobs&#39;, random_state=None, refit=True, return_train_score=False, scoring=None, verbose=True) . # Find the best model hyperparameters rs_model.best_params_ . {&#39;n_estimators&#39;: 60, &#39;min_samples_split&#39;: 8, &#39;min_samples_leaf&#39;: 17, &#39;max_samples&#39;: 10000, &#39;max_features&#39;: &#39;auto&#39;, &#39;max_depth&#39;: 10} . # Evaluate the RandomizedSearch model show_scores(rs_model) . {&#39;Train MAE&#39;: 6781.133667699814, &#39;Valid MAE&#39;: 8273.13603628744, &#39;Training RMSLE&#39;: 0.3018548489078088, &#39;Valid RMSLE&#39;: 0.3288263215115839, &#39;Training R^2&#39;: 0.7978179865228853, &#39;Valid R^2&#39;: 0.772217212393837} . Train a model with the best hyperparamters . Note: These were found after 100 iterations of RandomizedSearchCV. . %%time # Most ideal hyperparameters ideal_model = RandomForestRegressor(n_estimators=40, min_samples_leaf=1, min_samples_split=14, max_features=0.5, n_jobs=-1, max_samples=None, random_state=42) # random state # Fit the ideal model ideal_model.fit(X_train, y_train) . Wall time: 1min 27s . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=0.5, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=14, min_weight_fraction_leaf=0.0, n_estimators=40, n_jobs=-1, oob_score=False, random_state=42, verbose=0, warm_start=False) . # Scores for ideal_model (trained on all the data) show_scores(ideal_model) . {&#39;Train MAE&#39;: 2953.8161137163484, &#39;Valid MAE&#39;: 5951.247761444453, &#39;Training RMSLE&#39;: 0.14469006962371858, &#39;Valid RMSLE&#39;: 0.24524163989538328, &#39;Training R^2&#39;: 0.9588145522577225, &#39;Valid R^2&#39;: 0.8818019502450094} . # Scores on rs_model (only trained on -10,000 examples) show_scores(rs_model) . {&#39;Train MAE&#39;: 6781.133667699814, &#39;Valid MAE&#39;: 8273.13603628744, &#39;Training RMSLE&#39;: 0.3018548489078088, &#39;Valid RMSLE&#39;: 0.3288263215115839, &#39;Training R^2&#39;: 0.7978179865228853, &#39;Valid R^2&#39;: 0.772217212393837} . # Import the test data df_test = pd.read_csv(&quot;data/Test.csv&quot;, low_memory=False, parse_dates=[&quot;saledate&quot;]) df_test.head() . SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand saledate fiModelDesc ... Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls . 0 1227829 | 1006309 | 3168 | 121 | 3 | 1999 | 3688.0 | Low | 2012-05-03 | 580G | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1 1227844 | 1022817 | 7271 | 121 | 3 | 1000 | 28555.0 | High | 2012-05-10 | 936 | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | Standard | Conventional | . 2 1227847 | 1031560 | 22805 | 121 | 3 | 2004 | 6038.0 | Medium | 2012-05-10 | EC210BLC | ... | None or Unspecified | 9&#39; 6&quot; | Manual | None or Unspecified | Double | NaN | NaN | NaN | NaN | NaN | . 3 1227848 | 56204 | 1269 | 121 | 3 | 2006 | 8940.0 | High | 2012-05-10 | 330CL | ... | None or Unspecified | None or Unspecified | Manual | Yes | Triple | NaN | NaN | NaN | NaN | NaN | . 4 1227863 | 1053887 | 22312 | 121 | 3 | 2005 | 2286.0 | Low | 2012-05-10 | 650K | ... | NaN | NaN | NaN | NaN | NaN | None or Unspecified | PAT | None or Unspecified | NaN | NaN | . 5 rows × 52 columns . # Make predictions on the test dataset test_preds = ideal_model.predict(df_test) . - ValueError Traceback (most recent call last) &lt;ipython-input-53-dcaddf54aa59&gt; in &lt;module&gt; 1 # Make predictions on the test dataset -&gt; 2 test_preds = ideal_model.predict(df_test) ~ bulldozer-price-project env lib site-packages sklearn ensemble _forest.py in predict(self, X) 764 check_is_fitted(self) 765 # Check data --&gt; 766 X = self._validate_X_predict(X) 767 768 # Assign chunk of trees to jobs ~ bulldozer-price-project env lib site-packages sklearn ensemble _forest.py in _validate_X_predict(self, X) 410 check_is_fitted(self) 411 --&gt; 412 return self.estimators_[0]._validate_X_predict(X, check_input=True) 413 414 @property ~ bulldozer-price-project env lib site-packages sklearn tree _classes.py in _validate_X_predict(self, X, check_input) 378 &#34;&#34;&#34;Validate X whenever one tries to predict, apply, predict_proba&#34;&#34;&#34; 379 if check_input: --&gt; 380 X = check_array(X, dtype=DTYPE, accept_sparse=&#34;csr&#34;) 381 if issparse(X) and (X.indices.dtype != np.intc or 382 X.indptr.dtype != np.intc): ~ bulldozer-price-project env lib site-packages sklearn utils validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, warn_on_dtype, estimator) 529 array = array.astype(dtype, casting=&#34;unsafe&#34;, copy=False) 530 else: --&gt; 531 array = np.asarray(array, order=order, dtype=dtype) 532 except ComplexWarning: 533 raise ValueError(&#34;Complex data not supported n&#34; ~ bulldozer-price-project env lib site-packages numpy core _asarray.py in asarray(a, dtype, order) 83 84 &#34;&#34;&#34; &gt; 85 return array(a, dtype, copy=False, order=order) 86 87 ValueError: could not convert string to float: &#39;Low&#39; . Preprocessing the data (getting the test data in the same format as our training dataset) . def preprocess_data(df): &quot;&quot;&quot; Performs transformations on df and returns transformed df. &quot;&quot;&quot; df[&quot;saleYear&quot;] = df.saledate.dt.year df[&quot;saleMonth&quot;] = df.saledate.dt.month df[&quot;saleDay&quot;] = df.saledate.dt.day df[&quot;saleDayOfWeek&quot;] = df.saledate.dt.dayofweek df[&quot;saleDayOfYear&quot;] = df.saledate.dt.dayofyear df.drop(&quot;saledate&quot;, axis=1, inplace=True) # Fill the numeric rows with median for label, content in df.items(): if pd.api.types.is_numeric_dtype(content): if pd.isnull(content).sum(): # Add a binary column which tells us if the data was missing df[label+&quot;_is_missing&quot;] = pd.isnull(content) # Fill missing numeric values with median df[label] = content.fillna(content.median()) # Fill categorical missing data and turn categories into numbers if not pd.api.types.is_numeric_dtype(content): df[label+&quot;_is_missing&quot;] = pd.isnull(content) # We add +1 to the category code because pandas encodes missing values as -1 df[label] = pd.Categorical(content).codes+1 return df . # Process the test data df_test = preprocess_data(df_test) df_test.head() . SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Undercarriage_Pad_Width_is_missing Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing . 0 1227829 | 1006309 | 3168 | 121 | 3 | 1999 | 3688.0 | 2 | 499 | 180 | ... | True | True | True | True | True | True | True | True | True | True | . 1 1227844 | 1022817 | 7271 | 121 | 3 | 1000 | 28555.0 | 1 | 831 | 292 | ... | True | True | True | True | True | True | True | True | False | False | . 2 1227847 | 1031560 | 22805 | 121 | 3 | 2004 | 6038.0 | 3 | 1177 | 404 | ... | False | False | False | False | False | True | True | True | True | True | . 3 1227848 | 56204 | 1269 | 121 | 3 | 2006 | 8940.0 | 1 | 287 | 113 | ... | False | False | False | False | False | True | True | True | True | True | . 4 1227863 | 1053887 | 22312 | 121 | 3 | 2005 | 2286.0 | 2 | 566 | 196 | ... | True | True | True | True | True | False | False | False | True | True | . 5 rows × 101 columns . # Make predictions on updated test data test_preds = ideal_model.predict(df_test) . - ValueError Traceback (most recent call last) &lt;ipython-input-56-816969861579&gt; in &lt;module&gt; 1 # Make predictions on updated test data -&gt; 2 test_preds = ideal_model.predict(df_test) ~ bulldozer-price-project env lib site-packages sklearn ensemble _forest.py in predict(self, X) 764 check_is_fitted(self) 765 # Check data --&gt; 766 X = self._validate_X_predict(X) 767 768 # Assign chunk of trees to jobs ~ bulldozer-price-project env lib site-packages sklearn ensemble _forest.py in _validate_X_predict(self, X) 410 check_is_fitted(self) 411 --&gt; 412 return self.estimators_[0]._validate_X_predict(X, check_input=True) 413 414 @property ~ bulldozer-price-project env lib site-packages sklearn tree _classes.py in _validate_X_predict(self, X, check_input) 386 n_features = X.shape[1] 387 if self.n_features_ != n_features: --&gt; 388 raise ValueError(&#34;Number of features of the model must &#34; 389 &#34;match the input. Model n_features is %s and &#34; 390 &#34;input n_features is %s &#34; ValueError: Number of features of the model must match the input. Model n_features is 102 and input n_features is 101 . X_train.head() . SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Undercarriage_Pad_Width_is_missing Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing . 0 1646770 | 1126363 | 8434 | 132 | 18.0 | 1974 | 0.0 | 0 | 4593 | 1744 | ... | True | True | True | True | True | False | False | False | True | True | . 1 1821514 | 1194089 | 10150 | 132 | 99.0 | 1980 | 0.0 | 0 | 1820 | 559 | ... | True | True | True | True | True | True | True | True | False | False | . 2 1505138 | 1473654 | 4139 | 132 | 99.0 | 1978 | 0.0 | 0 | 2348 | 713 | ... | True | True | True | True | True | False | False | False | True | True | . 3 1671174 | 1327630 | 8591 | 132 | 99.0 | 1980 | 0.0 | 0 | 1819 | 558 | ... | True | True | True | True | True | True | True | True | False | False | . 4 1329056 | 1336053 | 4089 | 132 | 99.0 | 1984 | 0.0 | 0 | 2119 | 683 | ... | True | True | True | True | True | False | False | False | True | True | . 5 rows × 102 columns . # We can find how the columns differ using sets set(X_train.columns) - set(df_test.columns) . {&#39;auctioneerID_is_missing&#39;} . # Manually adjust df_test to have auctioneerID_is_missing column df_test[&quot;auctionID_is_missing&quot;] = False df_test.head() . SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing auctionID_is_missing . 0 1227829 | 1006309 | 3168 | 121 | 3 | 1999 | 3688.0 | 2 | 499 | 180 | ... | True | True | True | True | True | True | True | True | True | False | . 1 1227844 | 1022817 | 7271 | 121 | 3 | 1000 | 28555.0 | 1 | 831 | 292 | ... | True | True | True | True | True | True | True | False | False | False | . 2 1227847 | 1031560 | 22805 | 121 | 3 | 2004 | 6038.0 | 3 | 1177 | 404 | ... | False | False | False | False | True | True | True | True | True | False | . 3 1227848 | 56204 | 1269 | 121 | 3 | 2006 | 8940.0 | 1 | 287 | 113 | ... | False | False | False | False | True | True | True | True | True | False | . 4 1227863 | 1053887 | 22312 | 121 | 3 | 2005 | 2286.0 | 2 | 566 | 196 | ... | True | True | True | True | False | False | False | True | True | False | . 5 rows × 102 columns . Finally now our test dataframe has the same features as our training dataframe, we can make predictions! . # Make predictions on the test data test_preds = ideal_model.predict(df_test) . len(test_preds) . 12457 . # Format predictions into the sae format Kaggle is after df_preds = pd.DataFrame() df_preds[&quot;SalesID&quot;] = df_test[&quot;SalesID&quot;] df_preds[&quot;SalesPrice&quot;] = test_preds df_preds . SalesID SalesPrice . 0 1227829 | 20614.367809 | . 1 1227844 | 19897.801707 | . 2 1227847 | 44852.219594 | . 3 1227848 | 68346.325323 | . 4 1227863 | 39487.349708 | . ... ... | ... | . 12452 6643171 | 46466.092910 | . 12453 6643173 | 17500.493352 | . 12454 6643184 | 14296.986205 | . 12455 6643186 | 22164.857577 | . 12456 6643196 | 31683.800634 | . 12457 rows × 2 columns . Feature Importance . Feature importance seeks to figure out which different attributes of the data were most importance when it comes to predicting the target variable (SalePrice). . # Find feature importance of our best model ideal_model.feature_importances_ . array([3.39445533e-02, 1.81148281e-02, 4.09167072e-02, 1.70752171e-03, 3.40797459e-03, 2.08200698e-01, 2.95067052e-03, 1.10113725e-03, 4.16122668e-02, 4.71911805e-02, 6.23815431e-02, 4.67433955e-03, 1.52524442e-02, 1.52517337e-01, 4.72224713e-02, 5.96817956e-03, 1.29351899e-03, 2.78088439e-03, 2.37248769e-03, 6.17114453e-02, 8.13525488e-04, 3.61873268e-05, 9.19098115e-04, 2.23170993e-04, 1.28102678e-03, 2.06519636e-05, 2.01477316e-03, 6.63364759e-03, 2.15274492e-03, 2.50178165e-03, 4.63902393e-03, 3.85873985e-03, 2.76062667e-03, 1.00782454e-03, 2.47969268e-04, 6.04239818e-03, 7.64997072e-04, 1.57100537e-02, 2.29716203e-03, 2.58372272e-03, 8.07637426e-04, 9.18548690e-04, 1.35656446e-03, 5.81458569e-04, 4.96716928e-04, 3.79552257e-04, 5.31712788e-04, 2.71823509e-03, 8.34294376e-04, 3.12136841e-04, 2.14075157e-04, 7.42422919e-02, 3.80158492e-03, 5.67641024e-03, 2.87154703e-03, 9.83349904e-03, 2.65470837e-04, 1.57946459e-03, 3.10058108e-04, 0.00000000e+00, 0.00000000e+00, 2.27421721e-03, 1.05632062e-03, 5.42819222e-03, 3.48484864e-02, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.90858845e-05, 9.09490682e-06, 1.31265147e-04, 5.29163902e-06, 1.11952381e-04, 4.78452431e-06, 3.43582863e-04, 5.57068428e-06, 1.07167376e-03, 3.99179008e-03, 4.07753410e-03, 1.05749617e-04, 2.76528927e-03, 2.59244312e-05, 3.51888176e-04, 2.31519337e-03, 1.99211177e-03, 4.02034629e-03, 2.03778082e-04, 1.13483313e-02, 9.02551628e-04, 1.58182497e-03, 4.63243398e-05, 2.92071004e-04, 3.11923094e-05, 1.56873538e-04, 2.87205987e-05, 3.80543083e-05, 2.55045807e-04, 1.66878572e-04, 2.10341792e-04, 1.26024842e-04, 9.40663015e-05]) . # Helper function for plotting feature importance def plot_features(columns, importances, n=20): df = (pd.DataFrame({&quot;features&quot;: columns, &quot;feature_importances&quot;: importances}) .sort_values(&quot;feature_importances&quot;, ascending=False) .reset_index(drop=True)) # Plot the dataframe fig, ax = plt.subplots() ax.barh(df[&quot;features&quot;][:n], df[&quot;feature_importances&quot;][:20]) ax.set_ylabel(&quot;Features&quot;) ax.set_xlabel(&quot;Fature importance&quot;) ax.invert_yaxis() . plot_features(X_train.columns, ideal_model.feature_importances_) . Question to finish: Why might knowing the feature importances of a trained machine learning model be helpful? . Final challenge: what other machine learning models could you try on our dataset? .",
            "url": "https://www.ai4love.xyz//2020/05/10/end-to-end-bulldozer-price-regression.html",
            "relUrl": "/2020/05/10/end-to-end-bulldozer-price-regression.html",
            "date": " • May 10, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Predicting heart disease using machine learning",
            "content": "We&#39;re going to take the following approach: . Problem definition | Data | Evaluation | Features | Modelling | Experimentation | 1. Problem Definition . In a statement, . Given clinical parameters about a patient, can we predict whether or not they have heart disease? . 2. Data . The original data came from the Cleavland data from the UCI Machine Learning Reporsitory. https://archive.ics.uci.edu/ml/datasets/Heart+Disease There is also a version of it available on Kaggle. https://www.kaggle.com/ronitf/heart-disease-uci . 3. Evaluation . If we can reach 95% accuracy at predicting whether or not a patient has heart disease during the proof of concept, we&#39;ll pursue the project. . 4. Features . This is where you&#39;ll get different information about each of the features in your data. . create data dictionary . age - age in years | sex - (1 = male; 0 = female) | cp - chest pain type 0:Typical angina: chest pain related decrease blood supply to the heart - 1: Atypical angina: chest pain not related to heart | 2: Non-anginal pain: typically esophageal spasms (non heart related) | 3: Aysmptomatic: chest pain not showing signs of disease | . | trestbps - resting blood pressure (in mm Hg on admission to the hospital): anything above 130-140 is typically cause for concern | chol - serum cholestoral in mg/dl serum = LDL + HDL + .2 * triglycerides | above 200 is cause for concern | . | fbs - (fasting blood sugar &gt; 120 mg/dl) (1 = true; 0 = false) &#39;&gt;126&#39; mg/dL signals diabetes | . | restecgresting electrocardiographic results 0: Nothing to note | 1: ST-T Wave abnormality can range from mild symptoms to servere problems | signals non-normal heart beat | . | 2: Possible or definite left ventricular hypertrophy Enlarged heart&#39;s main pumping chamber | . | . | thalach - maximum heart rate achieved | exang - exercise induced angina (1 = yes; 0 = no) | oldpeak - ST depression induced by exercise relative to rest looks at stress of heart during excercise unhealthy heart will stress more | . | slope - the slope of the peak exercise ST segment 0: Upsloping: better heart rate with exercise (uncommon) | 1: Flatsloping: minimal change (typical healthy heart) | 2: Downslopins: signs of unhealthy heart | . | ca - number of major vessels (0-3) colored by flourosopy colored vessel means the doctor can see the blood passing through | the more blood movement the better (no clots) | . | thal - thalium stress result 1,3: normal | 6: fixed defect (used to be defect but ok now) | 7: reversable defect (no proper blood movement when excercising) | . | target - have disease or not (1=yes, 0=no) (=the predicted attribute) | . Preparing the tools . We&#39;re going to use pandas, Matplotlib and NumPy for data analysis and manipulation. . # Import all the tools we need # Regular EDA (exploratory data analysis) and plotting libraries import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns # we want our plots to appear inside the notebook %matplotlib inline # Models from Scikit-Learn from sklearn.linear_model import LogisticRegression from sklearn.neighbors import KNeighborsClassifier from sklearn.ensemble import RandomForestClassifier # Model Evaluations from sklearn.model_selection import train_test_split, cross_val_score from sklearn.model_selection import RandomizedSearchCV, GridSearchCV from sklearn.metrics import confusion_matrix, classification_report from sklearn.metrics import precision_score, recall_score, f1_score from sklearn.metrics import plot_roc_curve . Load data . df = pd.read_csv(&quot;heart-disease.csv&quot;) df.shape # (rows, columns) . (303, 14) . Data Exploration (exploratory data analysis or EDA) . The goal here is to find out more about the data and become a subject matter export on the dataset you&#39;re working with. . What question(s) are you trying to solve? | What kind of data do we have and how do we treat different types? | What&#39;s missing from the data and how do you deal with it? | Where are the outliers and why should you care about them? | How can you add, change or remove features to get more out of your data? | df.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . df.tail() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 298 57 | 0 | 0 | 140 | 241 | 0 | 1 | 123 | 1 | 0.2 | 1 | 0 | 3 | 0 | . 299 45 | 1 | 3 | 110 | 264 | 0 | 1 | 132 | 0 | 1.2 | 1 | 0 | 3 | 0 | . 300 68 | 1 | 0 | 144 | 193 | 1 | 1 | 141 | 0 | 3.4 | 1 | 2 | 3 | 0 | . 301 57 | 1 | 0 | 130 | 131 | 0 | 1 | 115 | 1 | 1.2 | 1 | 1 | 3 | 0 | . 302 57 | 0 | 1 | 130 | 236 | 0 | 0 | 174 | 0 | 0.0 | 1 | 1 | 2 | 0 | . # Let&#39;s find out how many of each class there df[&quot;target&quot;].value_counts() . 1 165 0 138 Name: target, dtype: int64 . df[&quot;target&quot;].value_counts().plot(kind=&quot;bar&quot;, color=[&quot;salmon&quot;, &quot;lightblue&quot;]); . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 303 entries, 0 to 302 Data columns (total 14 columns): # Column Non-Null Count Dtype -- -- 0 age 303 non-null int64 1 sex 303 non-null int64 2 cp 303 non-null int64 3 trestbps 303 non-null int64 4 chol 303 non-null int64 5 fbs 303 non-null int64 6 restecg 303 non-null int64 7 thalach 303 non-null int64 8 exang 303 non-null int64 9 oldpeak 303 non-null float64 10 slope 303 non-null int64 11 ca 303 non-null int64 12 thal 303 non-null int64 13 target 303 non-null int64 dtypes: float64(1), int64(13) memory usage: 33.3 KB . # Are there any missing values? df.isna().sum() . age 0 sex 0 cp 0 trestbps 0 chol 0 fbs 0 restecg 0 thalach 0 exang 0 oldpeak 0 slope 0 ca 0 thal 0 target 0 dtype: int64 . df.describe() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . count 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | 303.000000 | . mean 54.366337 | 0.683168 | 0.966997 | 131.623762 | 246.264026 | 0.148515 | 0.528053 | 149.646865 | 0.326733 | 1.039604 | 1.399340 | 0.729373 | 2.313531 | 0.544554 | . std 9.082101 | 0.466011 | 1.032052 | 17.538143 | 51.830751 | 0.356198 | 0.525860 | 22.905161 | 0.469794 | 1.161075 | 0.616226 | 1.022606 | 0.612277 | 0.498835 | . min 29.000000 | 0.000000 | 0.000000 | 94.000000 | 126.000000 | 0.000000 | 0.000000 | 71.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | 0.000000 | . 25% 47.500000 | 0.000000 | 0.000000 | 120.000000 | 211.000000 | 0.000000 | 0.000000 | 133.500000 | 0.000000 | 0.000000 | 1.000000 | 0.000000 | 2.000000 | 0.000000 | . 50% 55.000000 | 1.000000 | 1.000000 | 130.000000 | 240.000000 | 0.000000 | 1.000000 | 153.000000 | 0.000000 | 0.800000 | 1.000000 | 0.000000 | 2.000000 | 1.000000 | . 75% 61.000000 | 1.000000 | 2.000000 | 140.000000 | 274.500000 | 0.000000 | 1.000000 | 166.000000 | 1.000000 | 1.600000 | 2.000000 | 1.000000 | 3.000000 | 1.000000 | . max 77.000000 | 1.000000 | 3.000000 | 200.000000 | 564.000000 | 1.000000 | 2.000000 | 202.000000 | 1.000000 | 6.200000 | 2.000000 | 4.000000 | 3.000000 | 1.000000 | . Heart Disease Frequency according to Sex . df.sex.value_counts() . 1 207 0 96 Name: sex, dtype: int64 . # Compare target column with sex column pd.crosstab(df.target, df.sex) . sex 0 1 . target . 0 24 | 114 | . 1 72 | 93 | . # Create a plot of crosstab pd.crosstab(df.target, df.sex).plot(kind=&quot;bar&quot;, figsize=(10, 6), color=[&quot;salmon&quot;, &quot;lightblue&quot;]) plt.title(&quot;Heart Disease Frequency for Sex&quot;) plt.xlabel(&quot;0 = No Disease, 1 = Disease&quot;) plt.ylabel(&quot;Amount&quot;) plt.legend([&quot;Female&quot;, &quot;Male&quot;]); plt.xticks(rotation=0); . Age vs. Max Heart Rate for Heart Disease . # Create another figure plt.figure(figsize=(10, 6)) # Scatter with positive examples plt.scatter(df.age[df.target==1], df.thalach[df.target==1], c=&quot;salmon&quot;) # Scatter with negative examples plt.scatter(df.age[df.target==0], df.thalach[df.target==0], c=&quot;lightblue&quot;) # Add some helpful info plt.title(&quot;Heart Disease in function of Age and Max Heart Rate&quot;) plt.xlabel(&quot;Age&quot;) plt.ylabel(&quot;Max Heart Rate&quot;) plt.legend([&quot;Disease&quot;, &quot;No Disease&quot;]); . # Check the distribution of the age column with a histogram df.age.plot.hist(); . Heart Disease Frequency per Chest Pain Type . cp - chest pain type 0: Typical angina: chest pain related decrease blood supply to the heart | 1: Atypical angina: chest pain not related to heart | 2: Non-anginal pain: typically esophageal spasms (non heart related) | 3: Asymptomatic: chest pain not showing signs or disease | . | pd.crosstab(df.cp, df.target) . target 0 1 . cp . 0 104 | 39 | . 1 9 | 41 | . 2 18 | 69 | . 3 7 | 16 | . # Make the crosstab more visual pd.crosstab(df.cp, df.target).plot(kind=&quot;bar&quot;, figsize=(10, 6), color=[&quot;salmon&quot;, &quot;lightblue&quot;]) # Add some communication plt.title(&quot;Heart Disease Frequency Per Chest Pain Type&quot;) plt.xlabel(&quot;Chest Pain Type&quot;) plt.ylabel(&quot;Amount&quot;) plt.legend([&quot;No Disease&quot;, &quot;Disease&quot;]) plt.xticks(rotation=0); . df.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . df.corr() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . age 1.000000 | -0.098447 | -0.068653 | 0.279351 | 0.213678 | 0.121308 | -0.116211 | -0.398522 | 0.096801 | 0.210013 | -0.168814 | 0.276326 | 0.068001 | -0.225439 | . sex -0.098447 | 1.000000 | -0.049353 | -0.056769 | -0.197912 | 0.045032 | -0.058196 | -0.044020 | 0.141664 | 0.096093 | -0.030711 | 0.118261 | 0.210041 | -0.280937 | . cp -0.068653 | -0.049353 | 1.000000 | 0.047608 | -0.076904 | 0.094444 | 0.044421 | 0.295762 | -0.394280 | -0.149230 | 0.119717 | -0.181053 | -0.161736 | 0.433798 | . trestbps 0.279351 | -0.056769 | 0.047608 | 1.000000 | 0.123174 | 0.177531 | -0.114103 | -0.046698 | 0.067616 | 0.193216 | -0.121475 | 0.101389 | 0.062210 | -0.144931 | . chol 0.213678 | -0.197912 | -0.076904 | 0.123174 | 1.000000 | 0.013294 | -0.151040 | -0.009940 | 0.067023 | 0.053952 | -0.004038 | 0.070511 | 0.098803 | -0.085239 | . fbs 0.121308 | 0.045032 | 0.094444 | 0.177531 | 0.013294 | 1.000000 | -0.084189 | -0.008567 | 0.025665 | 0.005747 | -0.059894 | 0.137979 | -0.032019 | -0.028046 | . restecg -0.116211 | -0.058196 | 0.044421 | -0.114103 | -0.151040 | -0.084189 | 1.000000 | 0.044123 | -0.070733 | -0.058770 | 0.093045 | -0.072042 | -0.011981 | 0.137230 | . thalach -0.398522 | -0.044020 | 0.295762 | -0.046698 | -0.009940 | -0.008567 | 0.044123 | 1.000000 | -0.378812 | -0.344187 | 0.386784 | -0.213177 | -0.096439 | 0.421741 | . exang 0.096801 | 0.141664 | -0.394280 | 0.067616 | 0.067023 | 0.025665 | -0.070733 | -0.378812 | 1.000000 | 0.288223 | -0.257748 | 0.115739 | 0.206754 | -0.436757 | . oldpeak 0.210013 | 0.096093 | -0.149230 | 0.193216 | 0.053952 | 0.005747 | -0.058770 | -0.344187 | 0.288223 | 1.000000 | -0.577537 | 0.222682 | 0.210244 | -0.430696 | . slope -0.168814 | -0.030711 | 0.119717 | -0.121475 | -0.004038 | -0.059894 | 0.093045 | 0.386784 | -0.257748 | -0.577537 | 1.000000 | -0.080155 | -0.104764 | 0.345877 | . ca 0.276326 | 0.118261 | -0.181053 | 0.101389 | 0.070511 | 0.137979 | -0.072042 | -0.213177 | 0.115739 | 0.222682 | -0.080155 | 1.000000 | 0.151832 | -0.391724 | . thal 0.068001 | 0.210041 | -0.161736 | 0.062210 | 0.098803 | -0.032019 | -0.011981 | -0.096439 | 0.206754 | 0.210244 | -0.104764 | 0.151832 | 1.000000 | -0.344029 | . target -0.225439 | -0.280937 | 0.433798 | -0.144931 | -0.085239 | -0.028046 | 0.137230 | 0.421741 | -0.436757 | -0.430696 | 0.345877 | -0.391724 | -0.344029 | 1.000000 | . # Let&#39;s make our correlation matrix a little prettier corr_matrix = df.corr() fig, ax = plt.subplots(figsize=(15, 10)) ax = sns.heatmap(corr_matrix, annot=True, linewidths=0.5, fmt=&quot;.2f&quot;, cmap=&quot;YlGnBu&quot;); bottom, top = ax.get_ylim() ax.set_ylim() . (14.0, 0.0) . 5. Modelling . df.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . # Split data into X and y X = df.drop(&quot;target&quot;, axis=1) y = df[&quot;target&quot;] . X . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 298 57 | 0 | 0 | 140 | 241 | 0 | 1 | 123 | 1 | 0.2 | 1 | 0 | 3 | . 299 45 | 1 | 3 | 110 | 264 | 0 | 1 | 132 | 0 | 1.2 | 1 | 0 | 3 | . 300 68 | 1 | 0 | 144 | 193 | 1 | 1 | 141 | 0 | 3.4 | 1 | 2 | 3 | . 301 57 | 1 | 0 | 130 | 131 | 0 | 1 | 115 | 1 | 1.2 | 1 | 1 | 3 | . 302 57 | 0 | 1 | 130 | 236 | 0 | 0 | 174 | 0 | 0.0 | 1 | 1 | 2 | . 303 rows × 13 columns . y . 0 1 1 1 2 1 3 1 4 1 .. 298 0 299 0 300 0 301 0 302 0 Name: target, Length: 303, dtype: int64 . # Split data into train and test sets np.random.seed(42) # Split into train &amp; test set X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) . X_train . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal . 132 42 | 1 | 1 | 120 | 295 | 0 | 1 | 162 | 0 | 0.0 | 2 | 0 | 2 | . 202 58 | 1 | 0 | 150 | 270 | 0 | 0 | 111 | 1 | 0.8 | 2 | 0 | 3 | . 196 46 | 1 | 2 | 150 | 231 | 0 | 1 | 147 | 0 | 3.6 | 1 | 0 | 2 | . 75 55 | 0 | 1 | 135 | 250 | 0 | 0 | 161 | 0 | 1.4 | 1 | 0 | 2 | . 176 60 | 1 | 0 | 117 | 230 | 1 | 1 | 160 | 1 | 1.4 | 2 | 2 | 3 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 188 50 | 1 | 2 | 140 | 233 | 0 | 1 | 163 | 0 | 0.6 | 1 | 1 | 3 | . 71 51 | 1 | 2 | 94 | 227 | 0 | 1 | 154 | 1 | 0.0 | 2 | 1 | 3 | . 106 69 | 1 | 3 | 160 | 234 | 1 | 0 | 131 | 0 | 0.1 | 1 | 1 | 2 | . 270 46 | 1 | 0 | 120 | 249 | 0 | 0 | 144 | 0 | 0.8 | 2 | 0 | 3 | . 102 63 | 0 | 1 | 140 | 195 | 0 | 1 | 179 | 0 | 0.0 | 2 | 2 | 2 | . 242 rows × 13 columns . y_train, len(y_train) . (132 1 202 0 196 0 75 1 176 0 .. 188 0 71 1 106 1 270 0 102 1 Name: target, Length: 242, dtype: int64, 242) . Now we&#39;ve got our data split into training and test sets, it&#39;s time to build a machine learning model. . We&#39;ll train it (find the patterns) on the trainig set. . And we&#39;ll test it (use the patterns) on the test set. . We&#39;re going to try 3 different machine learning models: . Logistic Regresssion | K-Nearest Neighbors Classifier | Random Forest Classifier | # Put models in a dictionary models = {&quot;Logistic Regression&quot;: LogisticRegression(), &quot;KNN&quot;: KNeighborsClassifier(), &quot;Random Forest&quot;: RandomForestClassifier()} # Create a function to fit and score models def fit_and_score(models, X_train, X_test, y_train, y_test): &quot;&quot;&quot; Fits and evaluates given machine learning models. models: a dict of different Scikit-Learn machine learning models X_train: training data (no labels) X_test: testing data (no labels) y_train: training labels y_test: test labels &quot;&quot;&quot; # set random seed np.random.seed(42) # Make a dictionary to keep model scores model_scores = {} # Loop through models for name, model in models.items(): # Fit the model to the data model.fit(X_train, y_train) # Evaluate the model and append its score to model_scores model_scores[name] = model.score(X_test, y_test) return model_scores . model_scores = fit_and_score(models=models, X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test) model_scores . C: Users LC heart-disease-project env lib site-packages sklearn linear_model _logistic.py:938: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression n_iter_i = _check_optimize_result( . {&#39;Logistic Regression&#39;: 0.8852459016393442, &#39;KNN&#39;: 0.6885245901639344, &#39;Random Forest&#39;: 0.8360655737704918} . Model Comparison . model_compare = pd.DataFrame(model_scores, index=[&quot;accuracy&quot;]) model_compare.T.plot.bar(); . Now we&#39;ve got a baseline model... and we know a model&#39;s first predictions aren&#39;t always what we should based our next steps off. What should we do? . Let&#39;s look at the following: . Hyperparameter tuning | Feature importance | Confusion matrix | Cross-validation | Precision | Recall | F1 score | Classification report | ROC curve | Area under the curve (AUC) | . Hyperparameter tuning (by hand) . # Let&#39;s tune KNN train_scores = [] test_scores = [] # Create a list of different values for n_neighbors neighbors = range(1, 21) # Setup KNN instance knn = KNeighborsClassifier() # Loop through different n_neighbors for i in neighbors: knn.set_params(n_neighbors=i) # Fit the algorithm knn.fit(X_train, y_train) # Update the training scores list train_scores.append(knn.score(X_train, y_train)) # Update the test scores list test_scores.append(knn.score(X_test, y_test)) . train_scores . [1.0, 0.8099173553719008, 0.7727272727272727, 0.743801652892562, 0.7603305785123967, 0.7520661157024794, 0.743801652892562, 0.7231404958677686, 0.71900826446281, 0.6942148760330579, 0.7272727272727273, 0.6983471074380165, 0.6900826446280992, 0.6942148760330579, 0.6859504132231405, 0.6735537190082644, 0.6859504132231405, 0.6652892561983471, 0.6818181818181818, 0.6694214876033058] . test_scores . [0.6229508196721312, 0.639344262295082, 0.6557377049180327, 0.6721311475409836, 0.6885245901639344, 0.7213114754098361, 0.7049180327868853, 0.6885245901639344, 0.6885245901639344, 0.7049180327868853, 0.7540983606557377, 0.7377049180327869, 0.7377049180327869, 0.7377049180327869, 0.6885245901639344, 0.7213114754098361, 0.6885245901639344, 0.6885245901639344, 0.7049180327868853, 0.6557377049180327] . plt.plot(neighbors, train_scores, label=&quot;Train score&quot;) plt.plot(neighbors, test_scores, label=&quot;Test score&quot;) plt.xticks(np.arange(1, 21, 1)) plt.xlabel(&quot;Number of neighbors&quot;) plt.ylabel(&quot;Model score&quot;) plt.legend() print(f&quot;Maximum KNN score on the test data: {max(test_scores)*100:.2f}%&quot;) . Maximum KNN score on the test data: 75.41% . Hyperparameter tuning with RandomizedSearchCV . We&#39;re going to tune: . LogisticRegression() | RandomForestClassifier() | . ...using RandomizedSearchCV . # Create a hyperparameter grid for LogisticRegression log_reg_grid = {&quot;C&quot;: np.logspace(-4, 4, 20), &quot;solver&quot;: [&quot;liblinear&quot;]} # Create a hyperparamter grid for RandomForestClassifier rf_grid = {&quot;n_estimators&quot;: np.arange(10, 1000, 50), &quot;max_depth&quot;: [None, 3, 5, 10], &quot;min_samples_split&quot;: np.arange(2, 20, 2), &quot;min_samples_leaf&quot;: np.arange(1, 20, 2)} . Now we&#39;ve got hyperparameter grids setup for each of our models, let&#39;s tune the using RandomizedSearchCV... . # Tune LogisticRegression np.random.seed(42) # Setup random hypterparameter search for LogisticRegression rs_log_reg = RandomizedSearchCV(LogisticRegression(), param_distributions=log_reg_grid, cv=5, n_iter=20, verbose=True) # Fit random hyperparamter search model for LogisticRegression rs_log_reg.fit(X_train, y_train) . Fitting 5 folds for each of 20 candidates, totalling 100 fits . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. [Parallel(n_jobs=1)]: Done 100 out of 100 | elapsed: 0.5s finished . RandomizedSearchCV(cv=5, error_score=nan, estimator=LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, l1_ratio=None, max_iter=100, multi_class=&#39;auto&#39;, n_jobs=None, penalty=&#39;l2&#39;, random_state=None, solver=&#39;lbfgs&#39;, tol=0.0001, verbose=0, warm_start=False), iid=&#39;deprecated&#39;, n_iter=20, n_jobs=None, param_distributions={&#39;C&#39;:... 4.83293024e-03, 1.27427499e-02, 3.35981829e-02, 8.85866790e-02, 2.33572147e-01, 6.15848211e-01, 1.62377674e+00, 4.28133240e+00, 1.12883789e+01, 2.97635144e+01, 7.84759970e+01, 2.06913808e+02, 5.45559478e+02, 1.43844989e+03, 3.79269019e+03, 1.00000000e+04]), &#39;solver&#39;: [&#39;liblinear&#39;]}, pre_dispatch=&#39;2*n_jobs&#39;, random_state=None, refit=True, return_train_score=False, scoring=None, verbose=True) . rs_log_reg.best_params_ . {&#39;solver&#39;: &#39;liblinear&#39;, &#39;C&#39;: 0.23357214690901212} . rs_log_reg.score(X_test, y_test) . 0.8852459016393442 . Now we&#39;ve tuned LogisticRegression(). Let&#39;s do the same for RandomForestClassifer()... . # Setup random seed np.random.seed(42) # Setup random hyperparamter search for RandomForestClassifier rs_rf = RandomizedSearchCV(RandomForestClassifier(), param_distributions=rf_grid, cv=5, n_iter=20, verbose=True) # Fit random hyperparamter search model for RandomForestClassifier() rs_rf.fit(X_train, y_train) . Fitting 5 folds for each of 20 candidates, totalling 100 fits . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. [Parallel(n_jobs=1)]: Done 100 out of 100 | elapsed: 1.7min finished . RandomizedSearchCV(cv=5, error_score=nan, estimator=RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs... param_distributions={&#39;max_depth&#39;: [None, 3, 5, 10], &#39;min_samples_leaf&#39;: array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]), &#39;min_samples_split&#39;: array([ 2, 4, 6, 8, 10, 12, 14, 16, 18]), &#39;n_estimators&#39;: array([ 10, 60, 110, 160, 210, 260, 310, 360, 410, 460, 510, 560, 610, 660, 710, 760, 810, 860, 910, 960])}, pre_dispatch=&#39;2*n_jobs&#39;, random_state=None, refit=True, return_train_score=False, scoring=None, verbose=True) . # Find the best hyperparameters rs_rf.best_params_ . {&#39;n_estimators&#39;: 210, &#39;min_samples_split&#39;: 4, &#39;min_samples_leaf&#39;: 19, &#39;max_depth&#39;: 3} . # Evalutate the randomized search RandomForestClassifier model rs_rf.score(X_test, y_test) . 0.8688524590163934 . Hyperparameter Tuning with GridSearchCV . Since our LogisticRegression model provides the best scores so far, we&#39;ll try and improve them again using GridSearchCV... . # Different hyperparameters for our LogisticRegression model log_reg_grid = {&quot;C&quot;: np.logspace(-4, 4, 30), &quot;solver&quot;: [&quot;liblinear&quot;]} # Setup grid hyperparamter search for LogisticRegression gs_log_reg = GridSearchCV(LogisticRegression(), param_grid=log_reg_grid, cv=5, verbose=True) # Fit grid hyperparameter search model gs_log_reg.fit(X_train, y_train); . Fitting 5 folds for each of 30 candidates, totalling 150 fits . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. [Parallel(n_jobs=1)]: Done 150 out of 150 | elapsed: 0.7s finished . # Check the best hyperparameters gs_log_reg.best_params_ . {&#39;C&#39;: 0.20433597178569418, &#39;solver&#39;: &#39;liblinear&#39;} . # Evaluate the grid search LogisticRegression model gs_log_reg.score(X_test, y_test) . 0.8852459016393442 . Evaluating our tuned machine learning classifier, beyond accuracy . ROC curve and AUC score | Confusion matrix | Classification report | Precision | Recall | F1-score | . ...and it would be great if cross-validation was used where possible. . To make comparisons and evaluate our trained model, first we need to make predictions. . # Make predictions with tuned model y_preds = gs_log_reg.predict(X_test) . y_preds . array([0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], dtype=int64) . y_test . 179 0 228 0 111 1 246 0 60 1 .. 249 0 104 1 300 0 193 0 184 0 Name: target, Length: 61, dtype: int64 . # Plot ROC curve and calculate AUC metric plot_roc_curve(gs_log_reg, X_test, y_test) . &lt;sklearn.metrics._plot.roc_curve.RocCurveDisplay at 0xb3b0ee0&gt; . # Confusion matrix print(confusion_matrix(y_test, y_preds)) . [[25 4] [ 3 29]] . sns.set(font_scale=1.5) def plot_conf_mat(y_test, y_preds): &quot;&quot;&quot; Plots a nice looking confusion matrix using Seaborn&#39;s heatmap() &quot;&quot;&quot; fig, ax = plt.subplots(figsize=(3, 3)) ax = sns.heatmap(confusion_matrix(y_test, y_preds), annot=True, cbar=False) plt.xlabel(&quot;True label&quot;) plt.ylabel(&quot;Predicted label&quot;) bottom, top = ax.get_ylim() ax.set_ylim() plot_conf_mat(y_test, y_preds) . Now we&#39;ve got a ROC curve, and AUC metric and a confusion matrix, . let&#39;s get a classification report as well as cross-validated precision, recall and f1-score. . print(classification_report(y_test, y_preds)) . precision recall f1-score support 0 0.89 0.86 0.88 29 1 0.88 0.91 0.89 32 accuracy 0.89 61 macro avg 0.89 0.88 0.88 61 weighted avg 0.89 0.89 0.89 61 . Calculate evaluation metrics using cross-validation . We&#39;re going to calculate accuracy, precision, recall and f1-score of our model using cross-validation, . to do so we&#39;ll be using cross_val_score(). . # Check best hyperparameters gs_log_reg.best_params_ . {&#39;C&#39;: 0.20433597178569418, &#39;solver&#39;: &#39;liblinear&#39;} . # Create a new classifier with best parameters clf = LogisticRegression(C=0.20433597178569418, solver=&quot;liblinear&quot;) . # Cross-validated accuracy cv_acc = cross_val_score(clf, X, y, cv=5, scoring=&quot;accuracy&quot;) cv_acc . array([0.81967213, 0.90163934, 0.8852459 , 0.88333333, 0.75 ]) . cv_acc = np.mean(cv_acc) cv_acc . 0.8479781420765027 . # Cross-validated precision cv_precision = cross_val_score(clf, X, y, cv=5, scoring=&quot;precision&quot;) cv_precision=np.mean(cv_precision) cv_precision . 0.8215873015873015 . # Cross-validated recall cv_recall = cross_val_score(clf, X, y, cv=5, scoring=&quot;recall&quot;) cv_recall = np.mean(cv_recall) cv_recall . 0.9272727272727274 . # Cross-validated f1-score cv_f1 = cross_val_score(clf, X, y, cv=5, scoring=&quot;f1&quot;) cv_f1 = np.mean(cv_f1) cv_f1 . 0.8705403543192143 . # Visualize cross-validated metrics cv_metrics = pd.DataFrame({&quot;Accuracy&quot;: cv_acc, &quot;Precision&quot;: cv_precision, &quot;Recall&quot;: cv_recall, &quot;F1&quot;: cv_f1}, index=[0]) cv_metrics.T.plot.bar(title=&quot;Cross-validated classification metrics&quot;, legend=False); . Feature Importance . Feature importance is another as asking, &quot;which features contributed most to the outcomes of the model and how did they contribute?&quot; . Finding feature importance is different for each machine learning model. One way to find feature importance is to search for &quot;(MODEL NAME) feature importance&quot;. . Let&#39;s find the feature importance for our LogisticRegression model... . # Fit an instance of LogisticRegression clf = LogisticRegression(C=0.20433597178569418, solver=&quot;liblinear&quot;) clf.fit(X_train, y_train); . # Check coef_ clf.coef_ . array([[ 0.00316728, -0.86044636, 0.66067051, -0.01156993, -0.00166374, 0.04386116, 0.31275829, 0.02459361, -0.60413071, -0.56862818, 0.45051626, -0.63609888, -0.67663381]]) . df.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . # Match coef&#39;s of features to columns feature_dict = dict(zip(df.columns, list(clf.coef_[0]))) feature_dict . {&#39;age&#39;: 0.003167278990517721, &#39;sex&#39;: -0.8604463644626569, &#39;cp&#39;: 0.6606705054012705, &#39;trestbps&#39;: -0.011569931335912368, &#39;chol&#39;: -0.0016637438070300692, &#39;fbs&#39;: 0.04386116284216185, &#39;restecg&#39;: 0.31275829369964075, &#39;thalach&#39;: 0.02459361297137234, &#39;exang&#39;: -0.6041307139378419, &#39;oldpeak&#39;: -0.5686281825180214, &#39;slope&#39;: 0.450516263738603, &#39;ca&#39;: -0.6360988840661891, &#39;thal&#39;: -0.6766338062111971} . # Visualize feature importance feature_df = pd.DataFrame(feature_dict, index=[0]) feature_df.T.plot.bar(title=&quot;Feature Importance&quot;, legend=False); . pd.crosstab(df[&quot;sex&quot;], df[&quot;target&quot;]) . target 0 1 . sex . 0 24 | 72 | . 1 114 | 93 | . pd.crosstab(df[&quot;slope&quot;], df[&quot;target&quot;]) . target 0 1 . slope . 0 12 | 9 | . 1 91 | 49 | . 2 35 | 107 | . slope - the slope of the peak exercise ST segment . 0: Upsloping: better rate with exercise (uncommon) | 1: Flatsloping: minimal change (typical healthy heart) | 2: Downslopins: signs of unhealthy heart | . 6. Experimentation . If you haven&#39;t hit your evaluation metric yet... ask yourself... . Could you collect more data? | Could you try a better model? Like CatBoost or XGBoost? | Could you improve the current models? (beyond what we&#39;ve done so far) | If your model is good enough (you have hit your evaluation metric) how would you export it and share it with others? | .",
            "url": "https://www.ai4love.xyz//2020/04/30/end-to-end-heart-disease-classification.html",
            "relUrl": "/2020/04/30/end-to-end-heart-disease-classification.html",
            "date": " • Apr 30, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Scikit-Learn Practice Exercises",
            "content": "# Setup matplotlib to plot inline (within the notebook) %matplotlib inline # Import the pyplot module of Matplotlib as plt import matplotlib.pyplot as plt # Import pandas under the abbreviation &#39;pd&#39; import pandas as pd # Import NumPy under the abbreviation &#39;np&#39; import numpy as np . End-to-end Scikit-Learn classification workflow . Let&#39;s start with an end to end Scikit-Learn workflow. . More specifically, we&#39;ll: . Get a dataset ready | Prepare a machine learning model to make predictions | Fit the model to the data and make a prediction | Evaluate the model&#39;s predictions | The data we&#39;ll be using is stored on GitHub. We&#39;ll start with heart-disease.csv, a dataset which contains anonymous patient data and whether or not they have heart disease. . Note: When viewing a .csv on GitHub, make sure it&#39;s in the raw format. For example, the URL should look like: https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv . 1. Getting a dataset ready . # Import the heart disease dataset and save it to a variable # using pandas and read_csv() # Hint: You can directly pass the URL of a csv to read_csv() heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) # Check the first 5 rows of the data heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . Our goal here is to build a machine learning model on all of the columns except target to predict target. . In essence, the target column is our target variable (also called y or labels) and the rest of the other columns are our independent variables (also called data or X). . And since our target variable is one thing or another (heart disease or not), we know our problem is a classification problem (classifying whether something is one thing or another). . Knowing this, let&#39;s create X and y by splitting our dataframe up. . # Create X (all columns except target) X = heart_disease.drop(&quot;target&quot;, axis=1) # Create y (only the target column) y = heart_disease[&quot;target&quot;] . Now we&#39;ve split our data into X and y, we&#39;ll use Scikit-Learn to split it into training and test sets. . # Import train_test_split from sklearn&#39;s model_selection module from sklearn.model_selection import train_test_split np.random.seed(42) # Use train_test_split to split X &amp; y into training and test sets X_train, X_test, y_train, y_test = train_test_split(X, y) . # View the different shapes of the training and test datasets X_train.shape, X_test.shape, y_train.shape, y_test.shape . ((227, 13), (76, 13), (227,), (76,)) . What do you notice about the different shapes of the data? . Since our data is now in training and test sets, we&#39;ll build a machine learning model to fit patterns in the training data and then make predictions on the test data. . To figure out which machine learning model we should use, you can refer to Scikit-Learn&#39;s machine learning map. . After following the map, you decide to use the RandomForestClassifier. . 2. Preparing a machine learning model . # Import the RandomForestClassifier from sklearn&#39;s ensemble module from sklearn.ensemble import RandomForestClassifier # Instantiate an instance of RandomForestClassifier as clf clf = RandomForestClassifier() . Now you&#39;ve got a RandomForestClassifier instance, let&#39;s fit it to the training data. . Once it&#39;s fit, we&#39;ll make predictions on the test data. . 3. Fitting a model and making predictions . # Fit the RandomForestClassifier to the training data clf.fit(X_train, y_train) . RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) . # Use the fitted model to make predictions on the test data and # save the predictions to a variable called y_preds y_preds = clf.predict(X_test) . 4. Evaluating a model&#39;s predictions . Evaluating predictions is as important making them. Let&#39;s check how our model did by comparing the predictions it made on the test data (y_preds) to the ground truth labels (y_test). . # Evaluate the fitted model on the training set using the score() function clf.score(X_train, y_train) . 1.0 . # Evaluate the fitted model on the test set using the score() function clf.score(X_test, y_test) . 0.8289473684210527 . How did you model go? | What metric does score() return for classifiers? | Did your model do better on the training dataset or test dataset? | . Experimenting with different classification models . Now we&#39;ve quickly covered an end-to-end Scikit-Learn workflow and since experimenting is a large part of machine learning, we&#39;ll now try a series of different machine learning models and see which gets the best results on our dataset. . Going through the Scikit-Learn machine learning map, we see there are a number of different classification models we can try (different models are in the green boxes). . For this exercise, the models we&#39;re going to try and compare are: . LinearSVC | KNeighborsClassifier (also known as K-Nearest Neighbors or KNN) | SVC (also known as support vector classifier, a form of support vector machine) | LogisticRegression (despite the name, this is actually a classifier) | RandomForestClassifier (an ensemble method and what we used above) | . We&#39;ll follow the same workflow we used above (except this time for multiple models): . Import a machine learning model | Get it ready | Fit it to the data and make predictions | Evaluate the fitted model | Note: Since we&#39;ve already got the data ready, we can reuse it in this section. . # Import LinearSVC from sklearn&#39;s svm module from sklearn.svm import LinearSVC # Import KNeighborsClassifier from sklearn&#39;s neighbors module from sklearn.neighbors import KNeighborsClassifier # Import SVC from sklearn&#39;s svm module from sklearn.svm import SVC # Import LogisticRegression from sklearn&#39;s linear_model module from sklearn.linear_model import LogisticRegression # Note: we don&#39;t have to import RandomForestClassifier, since we already have . Thanks to the consistency of Scikit-Learn&#39;s API design, we can use virtually the same code to fit, score and make predictions with each of our models. . To see which model performs best, we&#39;ll do the following: . Instantiate each model in a dictionary | Create an empty results dictionary | Fit each model on the training data | Score each model on the test data | Check the results | If you&#39;re wondering what it means to instantiate each model in a dictionary, see the example below. . # EXAMPLE: Instantiating a RandomForestClassifier() in a dictionary example_dict = {&quot;RandomForestClassifier&quot;: RandomForestClassifier()} # Create a dictionary called models which contains all of the classification models we&#39;ve imported # Make sure the dictionary is in the same format as example_dict # The models dictionary should contain 5 models models = {&quot;LinearSVC&quot;: LinearSVC(), &quot;KNN&quot;: KNeighborsClassifier(), &quot;SVC&quot;: SVC(), &quot;LogisticRegression&quot;: LogisticRegression(), &quot;RandomForestClassifier&quot;: RandomForestClassifier()} # Create an empty dictionary called results results = {} . Since each model we&#39;re using has the same fit() and score() functions, we can loop through our models dictionary and, call fit() on the training data and then call score() with the test data. . # EXAMPLE: Looping through example_dict fitting and scoring the model example_results = {} for model_name, model in example_dict.items(): model.fit(X_train, y_train) example_results[model_name] = model.score(X_test, y_test) # EXAMPLE: View the results example_results . {&#39;RandomForestClassifier&#39;: 0.8552631578947368} . # Loop through the models dictionary items, fitting the model on the training data # and appending the model name and model score on the test data to the results dictionary for model_name, model in models.items(): model.fit(X_train, y_train) results[model_name] = model.score(X_test, y_test) # View the results results . C: Users LC machine_learning env lib site-packages sklearn svm _base.py:946: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations. warnings.warn(&#34;Liblinear failed to converge, increase &#34; C: Users LC machine_learning env lib site-packages sklearn linear_model _logistic.py:938: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression n_iter_i = _check_optimize_result( . {&#39;LinearSVC&#39;: 0.6842105263157895, &#39;KNN&#39;: 0.6973684210526315, &#39;SVC&#39;: 0.6973684210526315, &#39;LogisticRegression&#39;: 0.881578947368421, &#39;RandomForestClassifier&#39;: 0.8552631578947368} . Which model performed the best? | Do the results change each time you run the cell? | Why do you think this is? | . Due to the randomness of how each model finds patterns in the data, you might notice different results each time. . Without manually setting the random state using the random_state parameter of some models or using a NumPy random seed, every time you run the cell, you&#39;ll get slightly different results. . Let&#39;s see this in effect by running the same code as the cell above, except this time setting a NumPy random seed equal to 42. . # Run the same code as the cell above, except this time set a NumPy random seed # equal to 42 np.random.seed(42) for model_name, model in models.items(): model.fit(X_train, y_train) results[model_name] = model.score(X_test, y_test) results . C: Users LC machine_learning env lib site-packages sklearn svm _base.py:946: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations. warnings.warn(&#34;Liblinear failed to converge, increase &#34; C: Users LC machine_learning env lib site-packages sklearn linear_model _logistic.py:938: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression n_iter_i = _check_optimize_result( . {&#39;LinearSVC&#39;: 0.4605263157894737, &#39;KNN&#39;: 0.6973684210526315, &#39;SVC&#39;: 0.6973684210526315, &#39;LogisticRegression&#39;: 0.881578947368421, &#39;RandomForestClassifier&#39;: 0.8157894736842105} . Run the cell above a few times, what do you notice about the results? | Which model performs the best this time? | What happens if you add a NumPy random seed to the cell where you called train_test_split() (towards the top of the notebook) and then rerun the cell above? | . Let&#39;s make our results a little more visual. . # Create a pandas dataframe with the data as the values of the results dictionary, # the index as the keys of the results dictionary and a single column called accuracy. # Be sure to save the dataframe to a variable. results_df = pd.DataFrame(results.values(), results.keys(), columns=[&quot;Accuracy&quot;]) # Create a bar plot of the results dataframe using plot.bar() results_df.plot.bar(); . Using np.random.seed(42) results in the LogisticRegression model perfoming the best (at least on my computer). . Let&#39;s tune its hyperparameters and see if we can improve it. . Hyperparameter Tuning . Remember, if you&#39;re ever trying to tune a machine learning models hyperparameters and you&#39;re not sure where to start, you can always search something like &quot;MODEL_NAME hyperparameter tuning&quot;. . In the case of LogisticRegression, you might come across articles, such as Hyperparameter Tuning Using Grid Search by Chris Albon. . The article uses GridSearchCV but we&#39;re going to be using RandomizedSearchCV. . The different hyperparameters to search over have been setup for you in log_reg_grid but feel free to change them. . # Different LogisticRegression hyperparameters log_reg_grid = {&quot;C&quot;: np.logspace(-4, 4, 20), &quot;solver&quot;: [&quot;liblinear&quot;]} . Since we&#39;ve got a set of hyperparameters we can import RandomizedSearchCV, pass it our dictionary of hyperparameters and let it search for the best combination. . # Setup np random seed of 42 np.random.seed(42) # Import RandomizedSearchCV from sklearn&#39;s model_selection module from sklearn.model_selection import RandomizedSearchCV # Setup an instance of RandomizedSearchCV with a LogisticRegression() estimator, # our log_reg_grid as the param_distributions, a cv of 5 and n_iter of 5. rs_log_reg = RandomizedSearchCV(estimator=LogisticRegression(), param_distributions=log_reg_grid, cv=5, n_iter=5, verbose=True) # Fit the instance of RandomizedSearchCV rs_log_reg.fit(X_train, y_train); . Fitting 5 folds for each of 5 candidates, totalling 25 fits . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. [Parallel(n_jobs=1)]: Done 25 out of 25 | elapsed: 0.1s finished . Once RandomizedSearchCV has finished, we can find the best hyperparmeters it found using the best_params_ attributes. . # Find the best parameters of the RandomizedSearchCV instance using the best_params_ attribute rs_log_reg.best_params_ . {&#39;solver&#39;: &#39;liblinear&#39;, &#39;C&#39;: 0.23357214690901212} . # Score the instance of RandomizedSearchCV using the test data rs_log_reg.score(X_test, y_test) . 0.8947368421052632 . After hyperparameter tuning, did the models score improve? What else could you try to improve it? Are there any other methods of hyperparameter tuning you can find for LogisticRegression? . Classifier Model Evaluation . We&#39;ve tried to find the best hyperparameters on our model using RandomizedSearchCV and so far we&#39;ve only been evaluating our model using the score() function which returns accuracy. . But when it comes to classification, you&#39;ll likely want to use a few more evaluation metrics, including: . Confusion matrix - Compares the predicted values with the true values in a tabular way, if 100% correct, all values in the matrix will be top left to bottom right (diagnol line). | Cross-validation - Splits your dataset into multiple parts and train and tests your model on each part and evaluates performance as an average. | Precision - Proportion of true positives over total number of samples. Higher precision leads to less false positives. | Recall - Proportion of true positives over total number of true positives and false positives. Higher recall leads to less false negatives. | F1 score - Combines precision and recall into one metric. 1 is best, 0 is worst. | Classification report - Sklearn has a built-in function called classification_report() which returns some of the main classification metrics such as precision, recall and f1-score. | ROC Curve - Receiver Operating Characterisitc is a plot of true positive rate versus false positive rate. | Area Under Curve (AUC) - The area underneath the ROC curve. A perfect model achieves a score of 1.0. | . Before we get to these, we&#39;ll instantiate a new instance of our model using the best hyerparameters found by RandomizedSearchCV. . # Instantiate a LogisticRegression classifier using the best hyperparameters from RandomizedSearchCV clf = LogisticRegression(solver=&quot;liblinear&quot;, C=0.23357214690901212) # Fit the new instance of LogisticRegression with the best hyperparameters on the training data clf.fit(X_train, y_train); . Now it&#39;s to import the relative Scikit-Learn methods for each of the classification evaluation metrics we&#39;re after. . # Import confusion_matrix and classification_report from sklearn&#39;s metrics module from sklearn.metrics import confusion_matrix, classification_report # Import precision_score, recall_score and f1_score from sklearn&#39;s metrics module from sklearn.metrics import precision_score, recall_score, f1_score # Import plot_roc_curve from sklearn&#39;s metrics module from sklearn.metrics import plot_roc_curve . Evaluation metrics are very often comparing a model&#39;s predictions to some ground truth labels. . Let&#39;s make some predictions on the test data using our latest model and save them to y_preds. . # Make predictions on test data and save them y_preds = clf.predict(X_test) . Time to use the predictions our model has made to evaluate it beyond accuracy. . # Create a confusion matrix using the confusion_matrix function confusion_matrix(y_test, y_preds) . array([[30, 5], [ 3, 38]], dtype=int64) . Challenge: The in-built confusion_matrix function in Scikit-Learn produces something not too visual, how could you make your confusion matrix more visual? . You might want to search something like &quot;how to plot a confusion matrix&quot;. Note: There may be more than one way to do this. . import sys !conda install --yes --prefix {sys.prefix} seaborn . Collecting package metadata (current_repodata.json): ...working... done . ==&gt; WARNING: A newer version of conda exists. &lt;== current version: 4.8.2 latest version: 4.8.3 Please update conda by running $ conda update -n base -c defaults conda . Solving environment: ...working... done ## Package Plan ## environment location: C: Users LC machine_learning env added / updated specs: - seaborn The following packages will be downloaded: package | build |-- seaborn-0.10.0 | py_0 163 KB Total: 163 KB The following NEW packages will be INSTALLED: seaborn pkgs/main/noarch::seaborn-0.10.0-py_0 Downloading and Extracting Packages seaborn-0.10.0 | 163 KB | | 0% seaborn-0.10.0 | 163 KB | 9 | 10% seaborn-0.10.0 | 163 KB | ###9 | 39% seaborn-0.10.0 | 163 KB | ####9 | 49% seaborn-0.10.0 | 163 KB | ########## | 100% Preparing transaction: ...working... done Verifying transaction: ...working... done Executing transaction: ...working... done . # Create a more visual confusion matrix # Import seaborn for improving visualisaztion of confusion matrix import seaborn as sns # Make confusion matrix more visual def plot_conf_mat(y_test, y_preds): &quot;&quot;&quot; Plots a confusion matrix using Seaborn&#39;s heatmap(). &quot;&quot;&quot; fig, ax = plt.subplots(figsize=(3, 3)) ax = sns.heatmap(confusion_matrix(y_test, y_preds), annot=True, # Annotate the boxes cbar=False) plt.xlabel(&quot;Predicted label&quot;) plt.ylabel(&quot;True label&quot;) plot_conf_mat(y_test, y_preds) . How about a classification report? . # Create a classification report using the classification_report function print(classification_report(y_test, y_preds)) . precision recall f1-score support 0 0.91 0.86 0.88 35 1 0.88 0.93 0.90 41 accuracy 0.89 76 macro avg 0.90 0.89 0.89 76 weighted avg 0.90 0.89 0.89 76 . Challenge: Write down what each of the columns in this classification report are. . Precision - Indicates the proportion of positive identifications (model predicted class 1) which were actually correct. A model which produces no false positives has a precision of 1.0. | Recall - Indicates the proportion of actual positives which were correctly classified. A model which produces no false negatives has a recall of 1.0. | F1 score - A combination of precision and recall. A perfect model achieves an F1 score of 1.0. | Support - The number of samples each metric was calculated on. | Accuracy - The accuracy of the model in decimal form. Perfect accuracy is equal to 1.0. | Macro avg - Short for macro average, the average precision, recall and F1 score between classes. Macro avg doesn’t class imbalance into effort, so if you do have class imbalances, pay attention to this metric. | Weighted avg - Short for weighted average, the weighted average precision, recall and F1 score between classes. Weighted means each metric is calculated with respect to how many samples there are in each class. This metric will favour the majority class (e.g. will give a high value when one class out performs another due to having more samples). | . The classification report gives us a range of values for precision, recall and F1 score, time to find these metrics using Scikit-Learn functions. . # Find the precision score of the model using precision_score() precision_score(y_test, y_preds) . 0.8837209302325582 . # Find the recall score recall_score(y_test, y_preds) . 0.926829268292683 . # Find the F1 score f1_score(y_test, y_preds) . 0.9047619047619047 . Confusion matrix: done. Classification report: done. ROC (receiver operator characteristic) curve &amp; AUC (area under curve) score: not done. . Let&#39;s fix this. . If you&#39;re unfamiliar with what a ROC curve, that&#39;s your first challenge, to read up on what one is. . In a sentence, a ROC curve is a plot of the true positive rate versus the false positive rate. . And the AUC score is the area behind the ROC curve. . Scikit-Learn provides a handy function for creating both of these called plot_roc_curve(). . # Plot a ROC curve using our current machine learning model using plot_roc_curve plot_roc_curve(clf, X_test, y_test); . Beautiful! We&#39;ve gone far beyond accuracy with a plethora extra classification evaluation metrics. . If you&#39;re not sure about any of these, don&#39;t worry, they can take a while to understand. That could be an optional extension, reading up on a classification metric you&#39;re not sure of. . The thing to note here is all of these metrics have been calculated using a single training set and a single test set. Whilst this is okay, a more robust way is to calculate them using cross-validation. . We can calculate various evaluation metrics using cross-validation using Scikit-Learn&#39;s cross_val_score() function along with the scoring parameter. . # Import cross_val_score from sklearn&#39;s model_selection module from sklearn.model_selection import cross_val_score . # EXAMPLE: By default cross_val_score returns 5 values (cv=5). cross_val_score(clf, X, y, scoring=&quot;accuracy&quot;, cv=5) . array([0.81967213, 0.90163934, 0.8852459 , 0.88333333, 0.75 ]) . # EXAMPLE: Taking the mean of the returned values from cross_val_score # gives a cross-validated version of the scoring metric. cross_val_acc = np.mean(cross_val_score(clf, X, y, scoring=&quot;accuracy&quot;, cv=5)) cross_val_acc . 0.8479781420765027 . In the examples, the cross-validated accuracy is found by taking the mean of the array returned by cross_val_score(). . Now it&#39;s time to find the same for precision, recall and F1 score. . # Find the cross-validated precision cross_val_precision = np.mean(cross_val_score(clf, X, y, scoring=&quot;precision&quot;, cv=5)) cross_val_precision . 0.8215873015873015 . # Find the cross-validated recall cross_val_recall = np.mean(cross_val_score(clf, X, y, scoring=&quot;recall&quot;, cv=5)) cross_val_recall . 0.9272727272727274 . # Find the cross-validated F1 score cross_val_f1 = np.mean(cross_val_score(clf, X, y, scoring=&quot;f1&quot;, cv=5)) cross_val_f1 . 0.8705403543192143 . Exporting and importing a trained model . Once you&#39;ve trained a model, you may want to export it and save it to file so you can share it or use it elsewhere. . One method of exporting and importing models is using the joblib library. . In Scikit-Learn, exporting and importing a trained model is known as model persistence. . # Import the dump and load functions from the joblib library from joblib import dump, load . # Use the dump function to export the trained model to file dump(clf, &quot;trained-classifier.joblib&quot;) . [&#39;trained-classifier.joblib&#39;] . # Use the load function to import the trained model you just exported # Save it to a different variable name to the origial trained model loaded_clf = load(&quot;trained-classifier.joblib&quot;) # Evaluate the loaded trained model on the test data loaded_clf.score(X_test, y_test) . 0.8947368421052632 . clf.score(X_test, y_test) . 0.8947368421052632 . What do you notice about the loaded trained model results versus the original (pre-exported) model results? . Looks the same! . Scikit-Learn Regression Practice . For the next few exercises, we&#39;re going to be working on a regression problem, in other words, using some data to predict a number. . Our dataset is a table of car sales, containing different car characteristics as well as a sale price. . We&#39;ll use Scikit-Learn&#39;s built-in regression machine learning models to try and learn the patterns in the car characteristics and their prices on a certain group of the dataset before trying to predict the sale price of a group of cars the model has never seen before. . To begin, we&#39;ll import the data from GitHub into a pandas DataFrame, check out some details about it and try to build a model as soon as possible. . # Read in the car sales data car_sales = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv&quot;) # View the first 5 rows of the car sales data car_sales.head() . Make Colour Odometer (KM) Doors Price . 0 Honda | White | 35431.0 | 4.0 | 15323.0 | . 1 BMW | Blue | 192714.0 | 5.0 | 19943.0 | . 2 Honda | White | 84714.0 | 4.0 | 28343.0 | . 3 Toyota | White | 154365.0 | 4.0 | 13434.0 | . 4 Nissan | Blue | 181577.0 | 3.0 | 14043.0 | . # Get information about the car sales DataFrame car_sales.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 1000 entries, 0 to 999 Data columns (total 5 columns): # Column Non-Null Count Dtype -- -- 0 Make 951 non-null object 1 Colour 950 non-null object 2 Odometer (KM) 950 non-null float64 3 Doors 950 non-null float64 4 Price 950 non-null float64 dtypes: float64(3), object(2) memory usage: 39.2+ KB . Looking at the output of info(), . How many rows are there total? | What datatypes are in each column? | How many missing values are there in each column? | . # Find number of missing values in each column car_sales.isna().sum() . Make 49 Colour 50 Odometer (KM) 50 Doors 50 Price 50 dtype: int64 . # Find the datatypes of each column of car_sales car_sales.dtypes . Make object Colour object Odometer (KM) float64 Doors float64 Price float64 dtype: object . Knowing this information, what would happen if we tried to model our data as it is? . Let&#39;s see. . # EXAMPLE: This doesn&#39;t work because our car_sales data isn&#39;t all numerical from sklearn.ensemble import RandomForestRegressor car_sales_X, car_sales_y = car_sales.drop(&quot;Price&quot;, axis=1), car_sales.Price rf_regressor = RandomForestRegressor().fit(car_sales_X, car_sales_y) . - ValueError Traceback (most recent call last) &lt;ipython-input-44-476d8071e1b5&gt; in &lt;module&gt; 2 from sklearn.ensemble import RandomForestRegressor 3 car_sales_X, car_sales_y = car_sales.drop(&#34;Price&#34;, axis=1), car_sales.Price -&gt; 4 rf_regressor = RandomForestRegressor().fit(car_sales_X, car_sales_y) ~ machine_learning env lib site-packages sklearn ensemble _forest.py in fit(self, X, y, sample_weight) 293 &#34;&#34;&#34; 294 # Validate or convert input data --&gt; 295 X = check_array(X, accept_sparse=&#34;csc&#34;, dtype=DTYPE) 296 y = check_array(y, accept_sparse=&#39;csc&#39;, ensure_2d=False, dtype=None) 297 if sample_weight is not None: ~ machine_learning env lib site-packages sklearn utils validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, warn_on_dtype, estimator) 529 array = array.astype(dtype, casting=&#34;unsafe&#34;, copy=False) 530 else: --&gt; 531 array = np.asarray(array, order=order, dtype=dtype) 532 except ComplexWarning: 533 raise ValueError(&#34;Complex data not supported n&#34; ~ machine_learning env lib site-packages numpy core _asarray.py in asarray(a, dtype, order) 83 84 &#34;&#34;&#34; &gt; 85 return array(a, dtype, copy=False, order=order) 86 87 ValueError: could not convert string to float: &#39;Honda&#39; . As we see, the cell above breaks because our data contains non-numerical values as well as missing data. . To take care of some of the missing data, we&#39;ll remove the rows which have no labels (all the rows with missing values in the Price column). . # Remove rows with no labels (NaN&#39;s in the Price column) car_sales.dropna(subset=[&quot;Price&quot;], inplace=True) . Building a pipeline . Since our car_sales data has missing numerical values as well as the data isn&#39;t all numerical, we&#39;ll have to fix these things before we can fit a machine learning model on it. . There are ways we could do this with pandas but since we&#39;re practicing Scikit-Learn, we&#39;ll see how we might do it with the Pipeline class. . Because we&#39;re modifying columns in our dataframe (filling missing values, converting non-numerical data to numbers) we&#39;ll need the ColumnTransformer, SimpleImputer and OneHotEncoder classes as well. . Finally, because we&#39;ll need to split our data into training and test sets, we&#39;ll import train_test_split as well. . # Import Pipeline from sklearn&#39;s pipeline module from sklearn.pipeline import Pipeline # Import ColumnTransformer from sklearn&#39;s compose module from sklearn.compose import ColumnTransformer # Import SimpleImputer from sklearn&#39;s impute module from sklearn.impute import SimpleImputer # Import OneHotEncoder from sklearn&#39;s preprocessing module from sklearn.preprocessing import OneHotEncoder # Import train_test_split from sklearn&#39;s model_selection module from sklearn.model_selection import train_test_split . Now we&#39;ve got the necessary tools we need to create our preprocessing Pipeline which fills missing values along with turning all non-numerical data into numbers. . Let&#39;s start with the categorical features. . # Define different categorical features categorical_features = [&quot;Make&quot;, &quot;Colour&quot;] # Create categorical transformer Pipeline categorical_transformer = Pipeline(steps=[ # Set SimpleImputer strategy to &quot;constant&quot; and fill value to &quot;missing&quot; (&quot;imputer&quot;, SimpleImputer(strategy=&quot;constant&quot;, fill_value=&quot;missing&quot;)), # Set OneHotEncoder to ignore the unknowns (&quot;onehot&quot;, OneHotEncoder(handle_unknown=&quot;ignore&quot;))]) . It would be safe to treat Doors as a categorical feature as well, however since we know the vast majority of cars have 4 doors, we&#39;ll impute the missing Doors values as 4. . # Define Doors features door_feature = [&quot;Doors&quot;] # Create Doors transformer Pipeline door_transformer = Pipeline(steps=[ # Set SimpleImputer strategy to &quot;constant&quot; and fill value to 4 (&quot;imputer&quot;, SimpleImputer(strategy=&quot;constant&quot;, fill_value=4))]) . Now onto the numeric features. In this case, the only numeric feature is the Odometer (KM) column. Let&#39;s fill its missing values with the median. . # Define numeric features (only the Odometer (KM) column) numeric_features = [&quot;Odometer (KM)&quot;] # Crearte numeric transformer Pipeline numeric_transformer = Pipeline(steps=[ # Set SimpleImputer strategy to fill missing values with the &quot;Median&quot; (&quot;imputer&quot;, SimpleImputer(strategy=&quot;median&quot;))]) . Time to put all of our individual transformer Pipeline&#39;s into a single ColumnTransformer instance. . # Setup preprocessing steps (fill missing values, then convert to numbers) preprocessor = ColumnTransformer( transformers=[ # Use the categorical_transformer to transform the categorical_features (&quot;cat&quot;, categorical_transformer, categorical_features), # Use the door_transformer to transform the door_feature (&quot;door&quot;, door_transformer, door_feature), # Use the numeric_transformer to transform the numeric_features (&quot;num&quot;, numeric_transformer, numeric_features)]) . Boom! Now our preprocessor is ready, time to import some regression models to try out. . Comparing our data to the Scikit-Learn machine learning map, we can see there&#39;s a handful of different regression models we can try. . RidgeRegression | SVR(kernel=&quot;linear&quot;) - short for Support Vector Regressor, a form form of support vector machine. | SVR(kernel=&quot;rbf&quot;) - short for Support Vector Regressor, a form of support vector machine. | RandomForestRegressor - the regression version of RandomForestClassifier. | . # Import Ridge from sklearn&#39;s linear_model module from sklearn.linear_model import Ridge # Import SVR from sklearn&#39;s svm module from sklearn.svm import SVR # Import RandomForestRegressor from sklearn&#39;s ensemble module from sklearn.ensemble import RandomForestRegressor . Again, thanks to the design of the Scikit-Learn library, we&#39;re able to use very similar code for each of these models. . To test them all, we&#39;ll create a dictionary of regression models and an empty dictionary for regression model results. . # Create dictionary of model instances, there should be 4 total key, value pairs # in the form {&quot;model_name&quot;: model_instance}. # Don&#39;t forget there&#39;s two versions of SVR, one with a &quot;linear&quot; kernel and the # other with kernel set to &quot;rbf&quot;. regression_models = {&quot;Ridge&quot;: Ridge(), &quot;SVR_linear&quot;: SVR(kernel=&quot;linear&quot;), &quot;SVR_rbf&quot;: SVR(kernel=&quot;rbf&quot;), &quot;RandomForestRegressor&quot;: RandomForestRegressor()} # Create an empty dictionary for the regression results regression_results = {} . Our regression model dictionary is prepared as well as an empty dictionary to append results to, time to get the data split into X (feature variables) and y (target variable) as well as training and test sets. . In our car sales problem, we&#39;re trying to use the different characteristics of a car (X) to predict its sale price (y). . # Create car sales X data (every column of car_sales except Price) car_sales_X = car_sales.drop(&quot;Price&quot;, axis=1) # Create car sales y data (the Price column of car_sales) car_sales_y = car_sales[&quot;Price&quot;] . # Use train_test_split to split the car_sales_X and car_sales_y data into # training and test sets. # Give the test set 20% of the data using the test_size parameter. # For reproducibility set the random_state parameter to 42. car_X_train, car_X_test, car_y_train, car_y_test = train_test_split(car_sales_X, car_sales_y, test_size=0.2, random_state=42) # Check the shapes of the training and test datasets car_X_train.shape, car_X_test.shape, car_y_train.shape, car_y_test.shape . ((760, 4), (190, 4), (760,), (190,)) . How many rows are in each set? | How many columns are in each set? | . Alright, our data is split into training and test sets, time to build a small loop which is going to: . Go through our regression_models dictionary | Create a Pipeline which contains our preprocessor as well as one of the models in the dictionary | Fits the Pipeline to the car sales training data | Evaluates the target model on the car sales test data and appends the results to our regression_results dictionary | # Loop through the items in the regression_models dictionary for model_name, model in regression_models.items(): # Create a model Pipeline with a preprocessor step and model step model_pipeline = Pipeline(steps=[(&quot;preprocessor&quot;, preprocessor), (&quot;model&quot;, model)]) # Fit the model Pipeline to the car sales training data print(f&quot;Fitting {model_name}...&quot;) model_pipeline.fit(car_X_train, car_y_train) # Score the model Pipeline on the test data appending the model_name to the # results dictionary print(f&quot;Scoring {model_name}...&quot;) regression_results[model_name] = model_pipeline.score(car_X_test, car_y_test) . Fitting Ridge... Scoring Ridge... Fitting SVR_linear... Scoring SVR_linear... Fitting SVR_rbf... Scoring SVR_rbf... Fitting RandomForestRegressor... Scoring RandomForestRegressor... . Our regression models have been fit, let&#39;s see how they did! . # Check the results of each regression model by printing the regression_results # dictionary regression_results . {&#39;Ridge&#39;: 0.254026110579439, &#39;SVR_linear&#39;: -0.489452821008145, &#39;SVR_rbf&#39;: 0.0018546241516633755, &#39;RandomForestRegressor&#39;: 0.2291358152962253} . Which model did the best? | How could you improve its results? | What metric does the score() method of a regression model return by default? | . Since we&#39;ve fitted some models but only compared them via the default metric contained in the score() method (R^2 score or coefficient of determination), let&#39;s take the RidgeRegression model and evaluate it with a few other regression metrics. . Specifically, let&#39;s find: . R^2 (pronounced r-squared) or coefficient of determination - Compares your models predictions to the mean of the targets. Values can range from negative infinity (a very poor model) to 1. For example, if all your model does is predict the mean of the targets, its R^2 value would be 0. And if your model perfectly predicts a range of numbers it&#39;s R^2 value would be 1. | Mean absolute error (MAE) - The average of the absolute differences between predictions and actual values. It gives you an idea of how wrong your predictions were. | Mean squared error (MSE) - The average squared differences between predictions and actual values. Squaring the errors removes negative errors. It also amplifies outliers (samples which have larger errors). | Scikit-Learn has a few classes built-in which are going to help us with these, namely, mean_absolute_error, mean_squared_error and r2_score. . # Import mean_absolute_error from sklearn&#39;s metrics module from sklearn.metrics import mean_absolute_error # Import mean_squared_error from sklearn&#39;s metrics module from sklearn.metrics import mean_squared_error # Import r2_score from sklearn&#39;s metrics module from sklearn.metrics import r2_score . All the evaluation metrics we&#39;re concerned with compare a model&#39;s predictions with the ground truth labels. Knowing this, we&#39;ll have to make some predictions. . Let&#39;s create a Pipeline with the preprocessor and a Ridge() model, fit it on the car sales training data and then make predictions on the car sales test data. . # Create RidgeRegression Pipeline with preprocessor as the &quot;preprocessor&quot; and # Ridge() as the &quot;model&quot;. ridge_pipeline = Pipeline(steps=[(&quot;preprocessor&quot;, preprocessor), (&quot;model&quot;, Ridge())]) # Fit the RidgeRegression Pipeline to the car sales training data ridge_pipeline.fit(car_X_train, car_y_train) # Make predictions on the car sales test data using the RidgeRegression Pipeline car_y_preds = ridge_pipeline.predict(car_X_test) # View the first 50 predictions car_y_preds[:50] . array([18514.480873 , 22204.86580267, 11045.72092225, 6891.87687957, 8793.93970278, 10926.96786577, 15267.76229871, 13834.80312146, 20207.44377898, 14412.59968701, 6216.01228306, 16543.06707068, 11783.69374936, 13492.13284255, 14321.17899086, 16425.45131776, 15999.88230172, 9925.04252351, 11576.64865889, 11580.55130633, 10647.22402588, 13113.54464064, 17874.90033257, 23447.29246732, 11797.33019118, 14481.85336505, 18430.527126 , 14680.33044208, 20585.63901269, 19953.91395769, 18163.1170151 , 22366.43390174, 12435.69707467, 14265.25495748, 18351.62656383, 19564.58267503, 12213.05747919, 12479.20772529, 18677.93478691, 11284.89072638, 15278.54001605, 17378.81425165, 19247.77623181, 17343.90692672, 15048.12797569, 12724.44477165, 12389.86021752, 8475.63778401, 15255.49324105, 18602.79970861]) . Nice! Now we&#39;ve got some predictions, time to evaluate them. We&#39;ll find the mean squared error (MSE), mean absolute error (MAE) and R^2 score (coefficient of determination) of our model. . # EXAMPLE: Find the MSE by comparing the car sales test labels to the car sales predictions mse = mean_squared_error(car_y_test, car_y_preds) # Return the MSE mse . 49950182.63337458 . # Find the MAE by comparing the car sales test labels to the car sales predictions mae = mean_absolute_error(car_y_test, car_y_preds) # Return the MAE mae . 5713.8215208551555 . # Find the R^2 score by comparing the car sales test labels to the car sales predictions r2 = r2_score(car_y_test, car_y_preds) # Return the R^2 score r2 . 0.254026110579439 . Boom! Our model could potentially do with some hyperparameter tuning (this would be a great extension). And we could probably do with finding some more data on our problem, 1000 rows doesn&#39;t seem to be sufficient. . How would you export the trained regression model? | . Extensions . You should be proud. Getting this far means you&#39;ve worked through a classification problem and regression problem using pure (mostly) Scikit-Learn (no easy feat!). . For more exercises, check out the Scikit-Learn getting started documentation. A good practice would be to read through it and for the parts you find interesting, add them into the end of this notebook. . Finally, as always, remember, the best way to learn something new is to try it. And try it relentlessly. If you&#39;re unsure of how to do something, never be afraid to ask a question or search for something such as, &quot;how to tune the hyperparmaters of a scikit-learn ridge regression model&quot;. .",
            "url": "https://www.ai4love.xyz//2020/04/28/Scikit-learn-exercises.html",
            "relUrl": "/2020/04/28/Scikit-learn-exercises.html",
            "date": " • Apr 28, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Improving a model",
            "content": "# Standard imports import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline . First predictions = baseline predictions. First model = baseline model. . From a data perspective: . Could we collect more data? (generally, the more data, the better) | Could we improve our data? | . From a model perspective: . Is there a better model we could use? | Could we improve the current model? | . Hyperparameters vs. Parameters . Parameters = model find these patterns in data | Hyperparameters = settings on a model you can adjust to (potentially) improve its ability to find patterns | . Three ways to adjust hyperparameters: . By hand | Randomly with RandomSearchCV | Exhaustively with GridSearchCV | from sklearn.ensemble import RandomForestClassifier clf = RandomForestClassifier() . clf.get_params() . {&#39;bootstrap&#39;: True, &#39;ccp_alpha&#39;: 0.0, &#39;class_weight&#39;: None, &#39;criterion&#39;: &#39;gini&#39;, &#39;max_depth&#39;: None, &#39;max_features&#39;: &#39;auto&#39;, &#39;max_leaf_nodes&#39;: None, &#39;max_samples&#39;: None, &#39;min_impurity_decrease&#39;: 0.0, &#39;min_impurity_split&#39;: None, &#39;min_samples_leaf&#39;: 1, &#39;min_samples_split&#39;: 2, &#39;min_weight_fraction_leaf&#39;: 0.0, &#39;n_estimators&#39;: 100, &#39;n_jobs&#39;: None, &#39;oob_score&#39;: False, &#39;random_state&#39;: None, &#39;verbose&#39;: 0, &#39;warm_start&#39;: False} . We&#39;re going to try and adjust: . max_depth | max_features | min_samples_leaf | min_samples_split | n_estimators | . from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def evaluate_preds(y_true, y_preds): &quot;&quot;&quot; Performs evaluation comparison on y_true lables vs. y_preds labels on a classification model. &quot;&quot;&quot; accuracy = accuracy_score(y_true, y_preds) precision = precision_score(y_true, y_preds) recall = recall_score(y_true, y_preds) f1 = f1_score(y_true, y_preds) metric_dict = {&quot;accuracy&quot;: round(accuracy, 2), &quot;precision&quot;: round(precision, 2), &quot;recall&quot;: round(recall, 2), &quot;f1&quot;: round(f1, 2)} print(f&quot;Acc: {accuracy * 100:.2f}%&quot;) print(f&quot;Precision: {precision:.2f}&quot;) print(f&quot;Recall: {recall:.2f}&quot;) print(f&quot;F1 score: {f1:.2f}&quot;) return metric_dict . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . from sklearn.ensemble import RandomForestClassifier np.random.seed(2020) # shuffle the data heart_disease_shuffled = heart_disease.sample(frac=1) # Split into X &amp; y X = heart_disease_shuffled.drop(&quot;target&quot;, axis=1) y = heart_disease_shuffled[&quot;target&quot;] # Split the data into train, validation &amp; test sets train_split = round(0.7 * len(heart_disease_shuffled)) # 70% of data valid_split = round(train_split + 0.15 * len(heart_disease_shuffled)) # 15% of data X_train, y_train = X[:train_split], y[:train_split] X_valid, y_valid = X[train_split:valid_split], y[train_split:valid_split] X_test, y_test = X[valid_split:], y[valid_split:] len(X_train), len(X_valid), len(X_test) . (212, 45, 46) . clf = RandomForestClassifier() clf.fit(X_train, y_train) # Make baseline predicitons y_preds = clf.predict(X_valid) # Evaluate the classifier on validation set baseline_metrics = evaluate_preds(y_valid, y_preds) baseline_metrics . Acc: 93.33% Precision: 0.93 Recall: 0.96 F1 score: 0.95 . {&#39;accuracy&#39;: 0.93, &#39;precision&#39;: 0.93, &#39;recall&#39;: 0.96, &#39;f1&#39;: 0.95} . np.random.seed(2020) # Create a second classifier with different hyperparameters clf_2 = RandomForestClassifier(n_estimators=80) clf_2.fit(X_train, y_train) # Make predictions y_preds_2 = clf_2.predict(X_valid) # Evaluate the 2nd classifier clf_2_metrics = evaluate_preds(y_valid, y_preds_2) . Acc: 93.33% Precision: 0.93 Recall: 0.96 F1 score: 0.95 . 2. Hyperparameter tuning with RandomizedSearchCV . from sklearn.model_selection import RandomizedSearchCV from sklearn.model_selection import train_test_split grid = {&quot;n_estimators&quot;: [10, 100, 200, 500, 1000, 1200], &quot;max_depth&quot;: [None, 5, 10, 20, 30], &quot;max_features&quot;: [&quot;auto&quot;, &quot;sqrt&quot;], &quot;min_samples_split&quot;: [2, 4, 6], &quot;min_samples_leaf&quot;: [1, 2, 4]} np.random.seed(2020) # Split into X &amp; y X = heart_disease_shuffled.drop(&quot;target&quot;, axis=1) y = heart_disease_shuffled[&quot;target&quot;] # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate RandomForestClassifier clf = RandomForestClassifier(n_jobs=1) # Setup RandomizedSearchCV rs_clf = RandomizedSearchCV(estimator=clf, param_distributions=grid, n_iter=10, # number of models to try cv=5, verbose=2) # Fit the RandomizedSearchCV version of clf rs_clf.fit(X_train, y_train); . Fitting 5 folds for each of 10 candidates, totalling 50 fits [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20 . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. . [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20, total= 3.1s [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20 . [Parallel(n_jobs=1)]: Done 1 out of 1 | elapsed: 3.0s remaining: 0.0s . [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20, total= 3.1s [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20 [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20, total= 3.4s [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20 [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20, total= 3.2s [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20 [CV] n_estimators=1000, min_samples_split=4, min_samples_leaf=2, max_features=auto, max_depth=20, total= 3.1s [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None [CV] n_estimators=10, min_samples_split=6, min_samples_leaf=1, max_features=sqrt, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None, total= 0.0s [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None [CV] n_estimators=10, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=None, total= 0.0s [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20 [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20, total= 3.0s [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20 [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20, total= 3.0s [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20 [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20, total= 3.1s [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20 [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20, total= 3.7s [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20 [CV] n_estimators=1000, min_samples_split=2, min_samples_leaf=2, max_features=sqrt, max_depth=20, total= 3.2s [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10 [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10, total= 1.5s [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10 [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10, total= 1.5s [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10 [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10, total= 1.5s [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10 [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10, total= 1.5s [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10 [CV] n_estimators=500, min_samples_split=2, min_samples_leaf=4, max_features=auto, max_depth=10, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 1.6s [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 3.0s [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 3.0s [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 3.1s [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 3.0s [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None [CV] n_estimators=1000, min_samples_split=6, min_samples_leaf=4, max_features=sqrt, max_depth=None, total= 3.0s [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10 [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10, total= 0.0s [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10 [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10, total= 0.0s [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10 [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10, total= 0.0s [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10 [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10, total= 0.0s [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10 [CV] n_estimators=10, min_samples_split=2, min_samples_leaf=2, max_features=auto, max_depth=10, total= 0.0s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20 [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20 [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20 [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20, total= 1.5s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20 [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20, total= 1.8s [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20 [CV] n_estimators=500, min_samples_split=4, min_samples_leaf=4, max_features=auto, max_depth=20, total= 2.3s [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None, total= 0.7s [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None, total= 0.7s [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None, total= 0.6s [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None, total= 0.6s [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None [CV] n_estimators=200, min_samples_split=4, min_samples_leaf=2, max_features=sqrt, max_depth=None, total= 0.6s . [Parallel(n_jobs=1)]: Done 50 out of 50 | elapsed: 1.2min finished . rs_clf.best_params_ . {&#39;n_estimators&#39;: 1000, &#39;min_samples_split&#39;: 6, &#39;min_samples_leaf&#39;: 4, &#39;max_features&#39;: &#39;sqrt&#39;, &#39;max_depth&#39;: None} . # Make predictions with the best hyperparamters rs_y_preds = rs_clf.predict(X_test) # Evaluate the predictions rs_metrics = evaluate_preds(y_test, rs_y_preds) . Acc: 85.25% Precision: 0.79 Recall: 0.93 F1 score: 0.86 . 3. Hyperparameter tuning with GridSearchCV . grid . {&#39;n_estimators&#39;: [10, 100, 200, 500, 1000, 1200], &#39;max_depth&#39;: [None, 5, 10, 20, 30], &#39;max_features&#39;: [&#39;auto&#39;, &#39;sqrt&#39;], &#39;min_samples_split&#39;: [2, 4, 6], &#39;min_samples_leaf&#39;: [1, 2, 4]} . GridSearchCV will try all the combinations. . Use best_params_ to refine the grid. . grid_2 = {&#39;n_estimators&#39;: [100, 200, 500], &#39;max_depth&#39;: [None], &#39;max_features&#39;: [&#39;auto&#39;, &#39;sqrt&#39;], &#39;min_samples_split&#39;: [6], &#39;min_samples_leaf&#39;: [1, 2]} . from sklearn.model_selection import GridSearchCV np.random.seed(2020) # Split into X &amp; y X = heart_disease_shuffled.drop(&quot;target&quot;, axis=1) y = heart_disease_shuffled[&quot;target&quot;] # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate RandomForestClassifier clf = RandomForestClassifier(n_jobs=1) # Setup GridSearchCV gs_clf = GridSearchCV(estimator=clf, param_grid=grid_2, cv=5, verbose=2) # Fit the GridSearchCV version of clf gs_clf.fit(X_train, y_train); . Fitting 5 folds for each of 12 candidates, totalling 60 fits [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100 . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. . [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100 . [Parallel(n_jobs=1)]: Done 1 out of 1 | elapsed: 0.1s remaining: 0.0s . [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.5s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.5s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.5s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.1s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.5s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.5s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.1s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.2s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.1s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.1s [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=auto, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=1, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=100, total= 0.2s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=200, total= 0.4s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500 [CV] max_depth=None, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=500, total= 1.0s . [Parallel(n_jobs=1)]: Done 60 out of 60 | elapsed: 34.0s finished . gs_clf.best_params_ . {&#39;max_depth&#39;: None, &#39;max_features&#39;: &#39;sqrt&#39;, &#39;min_samples_leaf&#39;: 2, &#39;min_samples_split&#39;: 6, &#39;n_estimators&#39;: 200} . gs_y_preds = gs_clf.predict(X_test) # evaluate the predictions gs_metrics = evaluate_preds(y_test, gs_y_preds) . Acc: 85.25% Precision: 0.79 Recall: 0.93 F1 score: 0.86 . Lets compare our different models&#39; metrics. . compare_metrics = pd.DataFrame({&quot;baseline&quot;: baseline_metrics, &quot;clf_2&quot;: clf_2_metrics, &quot;random search&quot;: rs_metrics, &quot;grid search&quot;: gs_metrics}) compare_metrics . baseline clf_2 random search grid search . accuracy 0.93 | 0.93 | 0.85 | 0.85 | . precision 0.93 | 0.93 | 0.79 | 0.79 | . recall 0.96 | 0.96 | 0.93 | 0.93 | . f1 0.95 | 0.95 | 0.86 | 0.86 | . compare_metrics.plot.bar(figsize=(10, 8)); . Saving and loading machine learning models . There are two ways to save and load machine learning models: . With Python&#39;s Pickle module | With the joblib module | Pickle . import pickle # Save an existing model to file pickle.dump(gs_clf, open(&quot;gs_random_forest_model_1.pkl&quot;, &quot;wb&quot;)) . # Load a saved model loaded_pickle_model = pickle.load(open(&quot;gs_random_forest_model_1.pkl&quot;, &quot;rb&quot;)) . # Make some predictions pickle_y_preds = loaded_pickle_model.predict(X_test) evaluate_preds(y_test, pickle_y_preds) . Acc: 85.25% Precision: 0.79 Recall: 0.93 F1 score: 0.86 . {&#39;accuracy&#39;: 0.85, &#39;precision&#39;: 0.79, &#39;recall&#39;: 0.93, &#39;f1&#39;: 0.86} . We know the model is the same one if the accuracy remains the same. . Joblib . from joblib import dump, load # Save a model to file dump(gs_clf, filename=&quot;gs_random_forest_model_1.joblib&quot;) . [&#39;gs_random_forest_model_1.joblib&#39;] . # Import a saved joblib model loaded_joblib_model = load(filename=&quot;gs_random_forest_model_1.joblib&quot;) . # Make and evaluate joblib predictions joblib_y_preds = loaded_joblib_model.predict(X_test) evaluate_preds(y_test, joblib_y_preds) . Acc: 85.25% Precision: 0.79 Recall: 0.93 F1 score: 0.86 . {&#39;accuracy&#39;: 0.85, &#39;precision&#39;: 0.79, &#39;recall&#39;: 0.93, &#39;f1&#39;: 0.86} . Putting it all together! . data = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv&quot;) data . Make Colour Odometer (KM) Doors Price . 0 Honda | White | 35431.0 | 4.0 | 15323.0 | . 1 BMW | Blue | 192714.0 | 5.0 | 19943.0 | . 2 Honda | White | 84714.0 | 4.0 | 28343.0 | . 3 Toyota | White | 154365.0 | 4.0 | 13434.0 | . 4 Nissan | Blue | 181577.0 | 3.0 | 14043.0 | . ... ... | ... | ... | ... | ... | . 995 Toyota | Black | 35820.0 | 4.0 | 32042.0 | . 996 NaN | White | 155144.0 | 3.0 | 5716.0 | . 997 Nissan | Blue | 66604.0 | 4.0 | 31570.0 | . 998 Honda | White | 215883.0 | 4.0 | 4001.0 | . 999 Toyota | Blue | 248360.0 | 4.0 | 12732.0 | . 1000 rows × 5 columns . data.dtypes . Make object Colour object Odometer (KM) float64 Doors float64 Price float64 dtype: object . data.isna().sum() . Make 49 Colour 50 Odometer (KM) 50 Doors 50 Price 50 dtype: int64 . Steps we want to do (all in one cell): . Fill missing data | Convert data to numbers | Build a model on the data | # Getting data ready import pandas as pd from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder # Modelling from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import train_test_split, GridSearchCV # Setup random seed import numpy as np np.random.seed(2020) # Import data and drop rows with missing labels data = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv&quot;) data.dropna(subset=[&quot;Price&quot;], inplace=True) # Define different features and transformer pipeline categorical_features = [&quot;Make&quot;, &quot;Colour&quot;] categorical_transformer = Pipeline(steps=[ (&quot;imputer&quot;, SimpleImputer(strategy=&quot;constant&quot;, fill_value=&quot;missing&quot;)), (&quot;onehot&quot;, OneHotEncoder(handle_unknown=&quot;ignore&quot;)) ]) door_feature = [&quot;Doors&quot;] door_transformer = Pipeline(steps=[ (&quot;imputer&quot;, SimpleImputer(strategy=&quot;constant&quot;, fill_value=4)) ]) numeric_features = [&quot;Odometer (KM)&quot;] numeric_transformer = Pipeline(steps=[ (&quot;imputer&quot;, SimpleImputer(strategy=&quot;mean&quot;)) ]) # Setup preprocessing steps (fill missing values, then convert to numbers) preprocessor = ColumnTransformer( transformers=[ (&quot;cat&quot;, categorical_transformer, categorical_features), (&quot;door&quot;, door_transformer, door_feature), (&quot;num&quot;, numeric_transformer, numeric_features) ] ) # Creating a preprocessing and modelling pipleline model = Pipeline(steps=[ (&quot;preprocessor&quot;, preprocessor), (&quot;model&quot;, RandomForestRegressor()) ]) # Split data X = data.drop(&quot;Price&quot;, axis=1) y = data[&quot;Price&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Fit and score the model model.fit(X_train, y_train) model.score(X_test, y_test) . 0.09943714170819874 . It&#39;s also possible to use GridSearchCV or RandomizedSearchCV with our Pipeline. . # Use GridSearchCV with our regression Pipeline from sklearn.model_selection import GridSearchCV pipe_grid = { &quot;preprocessor__num__imputer__strategy&quot;: [&quot;mean&quot;, &quot;median&quot;], &quot;model__n_estimators&quot;: [100, 1000], &quot;model__max_depth&quot;: [None, 5], &quot;model__max_features&quot;: [&quot;auto&quot;], &quot;model__min_samples_split&quot;: [2, 4] } gs_model = GridSearchCV(model, pipe_grid, cv=5, verbose=2) gs_model.fit(X_train, y_train) . Fitting 5 folds for each of 16 candidates, totalling 80 fits [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean . [Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers. . [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean . [Parallel(n_jobs=1)]: Done 1 out of 1 | elapsed: 0.3s remaining: 0.0s . [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.7s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.5s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.5s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.2s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.6s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.4s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.0s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.0s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.9s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.0s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 3.1s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.0s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.9s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.9s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.2s [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=None, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 3.0s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.4s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.1s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median, total= 0.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.2s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.3s [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median [CV] model__max_depth=5, model__max_features=auto, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median, total= 2.3s . [Parallel(n_jobs=1)]: Done 80 out of 80 | elapsed: 2.0min finished . GridSearchCV(cv=5, error_score=nan, estimator=Pipeline(memory=None, steps=[(&#39;preprocessor&#39;, ColumnTransformer(n_jobs=None, remainder=&#39;drop&#39;, sparse_threshold=0.3, transformer_weights=None, transformers=[(&#39;cat&#39;, Pipeline(memory=None, steps=[(&#39;imputer&#39;, SimpleImputer(add_indicator=False, copy=True, fill_value=&#39;missing&#39;, missing_values=nan, strategy=&#39;constant&#39;, verbo... verbose=0, warm_start=False))], verbose=False), iid=&#39;deprecated&#39;, n_jobs=None, param_grid={&#39;model__max_depth&#39;: [None, 5], &#39;model__max_features&#39;: [&#39;auto&#39;], &#39;model__min_samples_split&#39;: [2, 4], &#39;model__n_estimators&#39;: [100, 1000], &#39;preprocessor__num__imputer__strategy&#39;: [&#39;mean&#39;, &#39;median&#39;]}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=False, scoring=None, verbose=2) . gs_model.score(X_test, y_test) . 0.22706234528702576 .",
            "url": "https://www.ai4love.xyz//2020/04/16/Improve-a-model.html",
            "relUrl": "/2020/04/16/Improve-a-model.html",
            "date": " • Apr 16, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Evaluating a machine learning model",
            "content": "Estimator score method | The scoring parameter | Problem-specific metric functions | # Standard imports import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline . 1. Evaluating a model with the score method . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split np.random.seed(2020) X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) clf = RandomForestClassifier() clf.fit(X_train, y_train) . RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None, criterion=&#39;gini&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) . clf.score(X_train, y_train) . 1.0 . clf.score(X_test, y_test) . 0.7868852459016393 . Let&#39;s do the same but for regression... . # Import Boston housing dataset from sklearn.datasets import load_boston boston = load_boston() boston; . # Turn boston into a pandas dataframe boston_df = pd.DataFrame(boston[&quot;data&quot;], columns=boston[&quot;feature_names&quot;]) boston_df[&quot;target&quot;] = pd.Series(boston[&quot;target&quot;]) boston_df.head() . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT target . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.90 | 4.98 | 24.0 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.90 | 9.14 | 21.6 | . 2 0.02729 | 0.0 | 7.07 | 0.0 | 0.469 | 7.185 | 61.1 | 4.9671 | 2.0 | 242.0 | 17.8 | 392.83 | 4.03 | 34.7 | . 3 0.03237 | 0.0 | 2.18 | 0.0 | 0.458 | 6.998 | 45.8 | 6.0622 | 3.0 | 222.0 | 18.7 | 394.63 | 2.94 | 33.4 | . 4 0.06905 | 0.0 | 2.18 | 0.0 | 0.458 | 7.147 | 54.2 | 6.0622 | 3.0 | 222.0 | 18.7 | 396.90 | 5.33 | 36.2 | . from sklearn.ensemble import RandomForestRegressor np.random.seed(2020) # Create the data X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] # Split into training and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate and fit model model = RandomForestRegressor().fit(X_train, y_train) . model.score(X_test, y_test) . 0.7873300907872445 . 2. Evaluating a model using the scoring parameter . from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestClassifier np.random.seed(2020) X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) clf = RandomForestClassifier() clf.fit(X_train, y_train); . clf.score(X_test, y_test) . 0.7868852459016393 . cross_val_score(clf, X, y) . array([0.81967213, 0.86885246, 0.78688525, 0.8 , 0.75 ]) . What does Cross-validation do under the hood? . . The sv=5 by default, but we can change it, for exapmle, to 10: . cross_val_score(clf, X, y, cv=10) . array([0.87096774, 0.74193548, 0.87096774, 0.9 , 0.9 , 0.8 , 0.73333333, 0.86666667, 0.76666667, 0.76666667]) . np.random.seed(2020) # Single training and test split score clf_single_score = clf.score(X_test, y_test) # Take the mean of 5-fold cross-validation score clf_cross_val_score = np.mean(cross_val_score(clf, X, y)) # Compare the two clf_single_score, clf_cross_val_score . (0.7868852459016393, 0.8149726775956283) . Default scoring parameter of classifier = mean accuracy . clf.score() . # Scoring parameter set to None by default cross_val_score(clf, X, y, cv=5, scoring=None) . array([0.83606557, 0.8852459 , 0.7704918 , 0.76666667, 0.78333333]) . So Why do we use cross-validation score? . To avoid getting lucky scores. . 3. Classification model evaluation metrics . Accuracy | Area under ROC curve | Confusion matrix | Classification report | 3.1 Accuracy . heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestClassifier np.random.seed(2020) X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] clf = RandomForestClassifier() cross_val_score = cross_val_score(clf, X, y) . np.mean(cross_val_score) . 0.8149726775956283 . print(f&quot;Heart Disease Classifier Cross-Validated Accuracy: {np.mean(cross_val_score) *100:.2f}%&quot;) . Heart Disease Classifier Cross-Validated Accuracy: 81.50% . 3.2 Area under the receiver operating characteristic curve (AUC/ROC) . Area under curve (AUC) | ROC curve | . ROC curves are a comparison of a model&#39;s true positive rate (tpr) versus a model&#39;s false positive rate (fpr). . True positive = model predicts 1 when truth is 1 | False positive = model predicts 1 when truth is 0 | True negative = model predicts 0 when truth is 0 | False negative = model predicts 1 when truth is 1 | . # Split data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) . from sklearn.metrics import roc_curve # Fit the classifier clf.fit(X_train, y_train) # Make predictions with probabilities y_probs = clf.predict_proba(X_test) y_probs[:10] . array([[0.25, 0.75], [0.19, 0.81], [0.76, 0.24], [0.99, 0.01], [0.46, 0.54], [0.36, 0.64], [0.01, 0.99], [0.21, 0.79], [0.45, 0.55], [0.08, 0.92]]) . y_probs_positive = y_probs[:, 1] y_probs_positive[:10] . array([0.75, 0.81, 0.24, 0.01, 0.54, 0.64, 0.99, 0.79, 0.55, 0.92]) . # Caculate fpr, tpr and thresholds fpr, tpr, thresholds = roc_curve(y_test, y_probs_positive) # Check the false positive rates fpr . array([0. , 0. , 0. , 0. , 0. , 0. , 0.03703704, 0.03703704, 0.03703704, 0.03703704, 0.07407407, 0.07407407, 0.07407407, 0.07407407, 0.11111111, 0.11111111, 0.14814815, 0.18518519, 0.18518519, 0.22222222, 0.22222222, 0.2962963 , 0.33333333, 0.33333333, 0.33333333, 0.37037037, 0.37037037, 0.44444444, 0.51851852, 0.51851852, 0.59259259, 0.7037037 , 0.74074074, 0.81481481, 0.88888889, 0.96296296, 1. ]) . # Create a function for plotting ROC curves def plot_roc_curve(fpr, tpr): &quot;&quot;&quot; Plots a ROC curve given the false positive rate (fpr) and true positive rate (tpr) of a model. &quot;&quot;&quot; # Plot roc curve plt.plot(fpr, tpr, color=&quot;orange&quot;, label=&quot;ROC&quot;) # Plot line with no predictive power (baseline) plt.plot([0, 1], [0, 1], color=&quot;darkblue&quot;, linestyle=&quot;--&quot;, label=&quot;Guessing&quot;) # Customize the plot plt.xlabel(&quot;False positive rate (fpr)&quot;) plt.ylabel(&quot;True positive rate (tpr)&quot;) plt.title(&quot;Receiver Operating Characteristic (ROC) Curve&quot;) plt.legend() plt.show() plot_roc_curve(fpr, tpr) . from sklearn.metrics import roc_auc_score roc_auc_score(y_test, y_probs_positive) . 0.8921568627450981 . # Plot perfect ROC curve and AUC score fpr, tpr, thresholds = roc_curve(y_test, y_test) plot_roc_curve(fpr, tpr) . # Perfect AUC score roc_auc_score(y_test, y_test) . 1.0 . 3.3 Confusion Matrix . A confusion matrix is a quick way to compare the labels a model predicts and the actual labels it was supposed to predict. . In essence, giving you an idea of where the model is getting confused. . from sklearn.metrics import confusion_matrix y_preds = clf.predict(X_test) confusion_matrix(y_test, y_preds) . array([[21, 6], [ 7, 27]], dtype=int64) . # Visualize confusion matrix with pd.crosstab() pd.crosstab(y_test, y_preds, rownames=[&quot;Actual Label&quot;], colnames=[&quot;Predicted Labels&quot;]) . Predicted Labels 0 1 . Actual Label . 0 21 | 6 | . 1 7 | 27 | . # How to install a conda package into the current environment from a Jupyter Notebook import sys !conda install --yes --prefix {sys.prefix} seaborn . Collecting package metadata (current_repodata.json): ...working... done . ==&gt; WARNING: A newer version of conda exists. &lt;== current version: 4.7.12 latest version: 4.8.3 Please update conda by running $ conda update -n base -c defaults conda . Solving environment: ...working... done # All requested packages already installed. . # Make our confusion matrix more visual with Seaborn&#39;s heatmap() import seaborn as sns # Set the font scale sns.set(font_scale=1.5) # Create a confusion matrix conf_mat = confusion_matrix(y_test, y_preds) # Plot it using Seaborn sns.heatmap(conf_mat); . def plot_conf_mat(conf_mat): &quot;&quot;&quot; Plot a confusion matrix using Seaborn&#39;s heatmap(). &quot;&quot;&quot; fig, ax = plt.subplots(figsize=(3,3)) ax = sns.heatmap(conf_mat, annot=True, # Annotate the boxes with conf_mat info cbar=False) plt.xlabel(&quot;True label&quot;) plt.ylabel(&quot;Predicted label&quot;); plot_conf_mat(conf_mat) . 3.4 Classification Report . from sklearn.metrics import classification_report print(classification_report(y_test, y_preds)) . precision recall f1-score support 0 0.75 0.78 0.76 27 1 0.82 0.79 0.81 34 accuracy 0.79 61 macro avg 0.78 0.79 0.78 61 weighted avg 0.79 0.79 0.79 61 . # Where precision and recall become valuable disease_true = np.zeros(10000) disease_true[0] = 1 # only one positive case disease_preds = np.zeros(10000) # model predicts every case as 0 pd.DataFrame(classification_report(disease_true, disease_preds, output_dict=True)) . E: machine_learning env lib site-packages sklearn metrics _classification.py:1272: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior. _warn_prf(average, modifier, msg_start, len(result)) . 0.0 1.0 accuracy macro avg weighted avg . precision 0.99990 | 0.0 | 0.9999 | 0.499950 | 0.99980 | . recall 1.00000 | 0.0 | 0.9999 | 0.500000 | 0.99990 | . f1-score 0.99995 | 0.0 | 0.9999 | 0.499975 | 0.99985 | . support 9999.00000 | 1.0 | 0.9999 | 10000.000000 | 10000.00000 | . To summarize classification metrics: . Accuracy is a good measure to start with if all classes are balanced (e.g. same amount of samples which are labelled with 0 or 1). | Precision and recall become more important when classes are imbalanced. | If false positive predictions are worse than false negatives, aim for higher precision. | If false negative predictions are worse than false positives, aim for higher recall. | F1-score is a combination of precision and recall. | . 4. Regression model evaluation metrics . Model evaluation metrics documentation - https://scikit-learn.org/stable/modules/model_evaluation.html . R^2 (pronounced r-squared) or coefficient of determination. | Mean absolute error (MAE) | Mean squared error (MSE) | 4.1 R^2 . What R-squared does: . Compares your models predictions to the mean of the target. Values can range from negative infinity (a very pool model) to 1. For example, if all your model does is predict the mean of the targets, its R^2 value would be 0. But if your model perfectly predicts a range of numbers, its R^2 values would be 1. . from sklearn.ensemble import RandomForestRegressor np.random.seed(2020) X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) model = RandomForestRegressor() model.fit(X_train, y_train); . model.score(X_test, y_test) . 0.7873300907872445 . from sklearn.metrics import r2_score # Fill an array with y_test mean y_test_mean = np.full(len(y_test), y_test.mean()) . y_test.mean() . 21.38823529411765 . r2_score(y_test, y_test_mean) . 0.0 . r2_score(y_test, y_test) . 1.0 . 4.2 Mean absolute error . MAE is the average of the absolute differences between predictions and actual values. It gives an idea of how wrong your model&#39;s predictions are. . # Mean absolute error from sklearn.metrics import mean_absolute_error y_preds = model.predict(X_test) mae = mean_absolute_error(y_test, y_preds) mae . 2.807558823529411 . df = pd.DataFrame(data={&quot;actual values&quot;: y_test, &quot;predicted values&quot;: y_preds}) df[&quot;differences&quot;] = df[&quot;predicted values&quot;] - df[&quot;actual values&quot;] df . actual values predicted values differences . 409 27.5 | 22.611 | -4.889 | . 247 20.5 | 21.114 | 0.614 | . 399 6.3 | 12.712 | 6.412 | . 300 24.8 | 29.828 | 5.028 | . 321 23.1 | 24.184 | 1.084 | . ... ... | ... | ... | . 204 50.0 | 47.663 | -2.337 | . 495 23.1 | 19.530 | -3.570 | . 244 17.6 | 18.785 | 1.185 | . 413 16.3 | 13.995 | -2.305 | . 216 23.3 | 21.388 | -1.912 | . 102 rows × 3 columns . 4.3 Mean squared error (MSE) . # Mean squared error from sklearn.metrics import mean_squared_error y_preds = model.predict(X_test) mse = mean_squared_error(y_test, y_preds) mse . 18.147552617647058 . # Calculate MSE by hand squared = np.square(df[&quot;differences&quot;]) squared.mean() . 18.147552617647058 . 4.4 Finally, using the scoring parameter . from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestClassifier np.random.seed(2020) X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] clf = RandomForestClassifier() . np.random.seed(2020) cv_acc = cross_val_score(clf, X, y) cv_acc . array([0.80327869, 0.90163934, 0.80327869, 0.78333333, 0.78333333]) . # Cross-validated accuracy print(f&#39;The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%&#39;) . The cross-validated accuracy is: 81.50% . np.random.seed(2020) cv_acc = cross_val_score(clf, X, y, scoring=&quot;accuracy&quot;) print(f&#39;The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%&#39;) . The cross-validated accuracy is: 81.50% . # Precision cv_precision = cross_val_score(clf, X, y, scoring=&quot;precision&quot;) np.mean(cv_precision) . 0.8149098212659334 . # Recall cv_recall = cross_val_score(clf, X, y, scoring=&quot;recall&quot;) np.mean(cv_recall) . 0.8363636363636363 . cv_f1 = cross_val_score(clf, X, y, scoring=&quot;f1&quot;) np.mean(cv_f1) . 0.8557553692891091 . How about the regression model? . from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestRegressor np.random.seed(2020) X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] model = RandomForestRegressor() . np.random.seed(2020) cv_r2 = cross_val_score(model, X, y, scoring=None) cv_r2 . array([0.7590384 , 0.85738467, 0.70144943, 0.45694151, 0.23590506]) . np.random.seed(2020) cv_r2 = cross_val_score(model, X, y, scoring=&quot;r2&quot;) cv_r2 . array([0.7590384 , 0.85738467, 0.70144943, 0.45694151, 0.23590506]) . # Mean absolute error cv_mae = cross_val_score(model, X, y, scoring=&quot;neg_mean_absolute_error&quot;) cv_mae . array([-2.12122549, -2.55272277, -3.58191089, -3.82661386, -3.06138614]) . # Mean sqaured error cv_mse = cross_val_score(model, X, y, scoring=&quot;neg_mean_squared_error&quot;) cv_mse . array([ -7.74356199, -13.29979953, -22.26308961, -45.66473461, -18.772259 ]) . Using different evaluation metrics as Scikit-Learn functions . Classification evaluation functions . from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split np.random.seed(2020) X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) clf = RandomForestClassifier() clf.fit(X_train, y_train) # Make some predictions y_preds = clf.predict(X_test) # Evaluate the classifier print(&quot;Classifier metrics on the test set&quot;) print(f&quot;Accuracy: {accuracy_score(y_test, y_preds)*100:.2f}%&quot;) print(f&quot;Precision: {precision_score(y_test, y_preds)*100:.2f}%&quot;) print(f&quot;Recall: {recall_score(y_test, y_preds)*100:.2f}%&quot;) print(f&quot;F1: {f1_score(y_test, y_preds)*100:.2f}%&quot;) . Classifier metrics on the test set Accuracy: 78.69% Precision: 78.95% Recall: 85.71% F1: 82.19% . Regression evaluation functions . from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import train_test_split np.random.seed(2020) X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) model = RandomForestRegressor() model.fit(X_train, y_train) # Make predictions using our regression model y_preds = model.predict(X_test) # Evaluate the regression model print(&quot;Regression model metrics on the test set&quot;) print(f&quot;R^2: {r2_score(y_test, y_preds)}&quot;) print(f&quot;MAE: {mean_absolute_error(y_test, y_preds)}&quot;) print(f&quot;MSE: {mean_squared_error(y_test, y_preds)}&quot;) . Regression model metrics on the test set R^2: 0.7873300907872445 MAE: 2.807558823529411 MSE: 18.147552617647058 .",
            "url": "https://www.ai4love.xyz//2020/04/11/Evaluate-a-model.html",
            "relUrl": "/2020/04/11/Evaluate-a-model.html",
            "date": " • Apr 11, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Fit the model/algorithm on our data and use it to make predictions",
            "content": "# Standard imports import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . 1. Fitting the model to the data . Different names for: . X = features, features variables, data | y = labels, targets, target variables | . # Import the RandomForestClassifier estimator class from sklearn.ensemble import RandomForestClassifier # Setup random seed np.random.seed(2020) # Make the data X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] # Split the data from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate Random Forest Classifier clf = RandomForestClassifier() # Fit the model to the data (training the machine learning model) clf.fit(X_train, y_train) # Evaluate the Random Forest Classifier (use the patterns the model has learned) clf.score(X_test, y_test) . 0.7868852459016393 . 2. Make predictions using a machine learning model . 2 ways to make predictions: . predict() | predict_proba() | # Use a trained model to make predictions clf.predict(X_test) . array([0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], dtype=int64) . np.array(y_test) . array([0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0], dtype=int64) . # Compare predictions to truth labels to evaluate the model y_preds = clf.predict(X_test) np.mean(y_preds == y_test) . 0.7868852459016393 . clf.score(X_test, y_test) . 0.7868852459016393 . from sklearn.metrics import accuracy_score accuracy_score(y_test, y_preds) . 0.7868852459016393 . Make predictions with predict_proba(): . # predict_proba() returns probabilities of a classification label clf.predict_proba(X_test[:5]) . array([[0.77, 0.23], [0.31, 0.69], [0.73, 0.27], [0.48, 0.52], [0.07, 0.93]]) . # Let&#39;s predict() on the same data... clf.predict(X_test[:5]) . array([0, 1, 0, 1, 1], dtype=int64) . predict() can also be used for regression models. . # Import Boston housing dataset from sklearn.datasets import load_boston boston = load_boston() boston; . # Turn boston into a pandas dataframe boston_df = pd.DataFrame(boston[&quot;data&quot;], columns=boston[&quot;feature_names&quot;]) boston_df[&quot;target&quot;] = pd.Series(boston[&quot;target&quot;]) boston_df.head() . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT target . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.90 | 4.98 | 24.0 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.90 | 9.14 | 21.6 | . 2 0.02729 | 0.0 | 7.07 | 0.0 | 0.469 | 7.185 | 61.1 | 4.9671 | 2.0 | 242.0 | 17.8 | 392.83 | 4.03 | 34.7 | . 3 0.03237 | 0.0 | 2.18 | 0.0 | 0.458 | 6.998 | 45.8 | 6.0622 | 3.0 | 222.0 | 18.7 | 394.63 | 2.94 | 33.4 | . 4 0.06905 | 0.0 | 2.18 | 0.0 | 0.458 | 7.147 | 54.2 | 6.0622 | 3.0 | 222.0 | 18.7 | 396.90 | 5.33 | 36.2 | . from sklearn.ensemble import RandomForestRegressor np.random.seed(2020) # Create the data X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] # Split into training and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate and fit model model = RandomForestRegressor().fit(X_train, y_train) # Make predictions y_preds = model.predict(X_test) . y_preds[:10] . array([22.611, 21.114, 12.712, 29.828, 24.184, 19.73 , 23.794, 35.071, 12.503, 23.377]) . np.array(y_test[:10]) . array([27.5, 20.5, 6.3, 24.8, 23.1, 14.5, 16.5, 15. , 10.2, 22.3]) . # Compare the predictions to the truth from sklearn.metrics import mean_absolute_error mean_absolute_error(y_test, y_preds) . 2.807558823529411 .",
            "url": "https://www.ai4love.xyz//2020/04/10/Fit-a-model-to-the-data.html",
            "relUrl": "/2020/04/10/Fit-a-model-to-the-data.html",
            "date": " • Apr 10, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Choosing the right estimator/algorithm for our problem",
            "content": "# Standard imports import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline . 1. Picking a machine learning model for a regression problem . # Import Boston housing dataset from sklearn.datasets import load_boston boston = load_boston() boston; . Turn boston into a pandas dataframe: . boston_df = pd.DataFrame(boston[&quot;data&quot;], columns=boston[&quot;feature_names&quot;]) boston_df[&quot;target&quot;] = pd.Series(boston[&quot;target&quot;]) boston_df.head() . CRIM ZN INDUS CHAS NOX RM AGE DIS RAD TAX PTRATIO B LSTAT target . 0 0.00632 | 18.0 | 2.31 | 0.0 | 0.538 | 6.575 | 65.2 | 4.0900 | 1.0 | 296.0 | 15.3 | 396.90 | 4.98 | 24.0 | . 1 0.02731 | 0.0 | 7.07 | 0.0 | 0.469 | 6.421 | 78.9 | 4.9671 | 2.0 | 242.0 | 17.8 | 396.90 | 9.14 | 21.6 | . 2 0.02729 | 0.0 | 7.07 | 0.0 | 0.469 | 7.185 | 61.1 | 4.9671 | 2.0 | 242.0 | 17.8 | 392.83 | 4.03 | 34.7 | . 3 0.03237 | 0.0 | 2.18 | 0.0 | 0.458 | 6.998 | 45.8 | 6.0622 | 3.0 | 222.0 | 18.7 | 394.63 | 2.94 | 33.4 | . 4 0.06905 | 0.0 | 2.18 | 0.0 | 0.458 | 7.147 | 54.2 | 6.0622 | 3.0 | 222.0 | 18.7 | 396.90 | 5.33 | 36.2 | . # How many samples? len(boston_df) . 506 . Let&#39;s try the Ridge Regression model: . from sklearn.linear_model import Ridge # Setup random seed np.random.seed(2020) # Create the data X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] # Split into train and test sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate Ridge model model = Ridge() model.fit(X_train, y_train) # Check the score of the Ridge model on test data model.score(X_test, y_test) . 0.7635674632126357 . How do we improve this model? . What if Ridge wasn&#39;t working? . Let&#39;s refer back to the map...https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html . Let&#39;s try the Random Forest Regressor: . from sklearn.ensemble import RandomForestRegressor # Setup random seed np.random.seed(2020) # Create the data X = boston_df.drop(&quot;target&quot;, axis=1) y = boston_df[&quot;target&quot;] # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate Random Forest Regressor rf = RandomForestRegressor() rf.fit(X_train, y_train) #Evaluate the Random Forest Regressor rf.score(X_test, y_test) . 0.7873300907872445 . 2. Choosing an estimator for a classification problem . Let&#39;s go to the map... https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . len(heart_disease) . 303 . Consulting the map and it says to try LinearSVC. . # Import the LinearSVC estimator class from sklearn.svm import LinearSVC # Setup random seed np.random.seed(2020) # Make the data X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate LinearSVC clf = LinearSVC(max_iter=100000) clf.fit(X_train, y_train) # Evaluate the LinearSVC clf.score(X_test, y_test) . E: machine_learning env lib site-packages sklearn svm _base.py:946: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations. warnings.warn(&#34;Liblinear failed to converge, increase &#34; . 0.7540983606557377 . # Import the RandomForestClassifier estimator class from sklearn.ensemble import RandomForestClassifier # Setup random seed np.random.seed(2020) # Make the data X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # Instantiate Random Forest Classifier clf = RandomForestClassifier() clf.fit(X_train, y_train) # Evaluate the Random Forest Classifier clf.score(X_test, y_test) . 0.7868852459016393 . Tidbit: . If you have structured data, use ensemble methods | If you have unstructured data, use deep learning or transfer learning |",
            "url": "https://www.ai4love.xyz//2020/04/06/Choosing-the-right-estimator.html",
            "relUrl": "/2020/04/06/Choosing-the-right-estimator.html",
            "date": " • Apr 6, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Getting our data ready to be used with machine learning",
            "content": "# Standard imports import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline . Three main things we have to do: . 1. Splitting the data into features and labels (usually `X` &amp; `y`) 2. Filling (also called imputing) or disregarding missing values 3. Converting non-numerical values to numerical values (also called feature encoding) . Let&#39;s still use our heart disease data by importing it from Github: . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . X = heart_disease.drop(&quot;target&quot;, axis=1) X.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | . y = heart_disease[&quot;target&quot;] y.head() . 0 1 1 1 2 1 3 1 4 1 Name: target, dtype: int64 . 1. Split the data into training and test sets: . from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) X_train.shape, X_test.shape, y_train.shape, y_test.shape . ((242, 13), (61, 13), (242,), (61,)) . What we are doing above is split the X into X_train &amp; X_test and the y into y_train &amp; y_test. . The test_size parameter can be replaced by train_size. You can use either one. The test_size represent the proportion of the dataset to include in the test split. And train_size refers to the train split, respectively. . In this case, we want to set the proportion for test split as 0.2, which means it is 0.8 for train split: . X.shape[0] * 0.8, X_train.shape[0] . (242.4, 242) . By adding up the train split and the test split, we can get the total dataset, which can be proved by the following calculation: . 242 + 61 == len(heart_disease) . True . 2. Make sure it&#39;s all numerical . The heart disease data owns completely numerical values, which is nice. . But in most cases, we probably see a dataset with non-numerical values. For example, the car sales dataset: . car_sales = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended.csv&quot;) car_sales.head() . Make Colour Odometer (KM) Doors Price . 0 Honda | White | 35431 | 4 | 15323 | . 1 BMW | Blue | 192714 | 5 | 19943 | . 2 Honda | White | 84714 | 4 | 28343 | . 3 Toyota | White | 154365 | 4 | 13434 | . 4 Nissan | Blue | 181577 | 3 | 14043 | . len(car_sales) . 1000 . car_sales.dtypes . Make object Colour object Odometer (KM) int64 Doors int64 Price int64 dtype: object . Now we know there are not numbers in the first two columns of the car_sales dataset. What if we try to fit a machine learning model on it and see what happens? . Split the data into X &amp; y: . X = car_sales.drop(&quot;Price&quot;, axis=1) y = car_sales[&quot;Price&quot;] . Split the data into training &amp; test: . X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) . Build machine learning model: . from sklearn.ensemble import RandomForestRegressor model = RandomForestRegressor() model.fit(X_train, y_train) model.score(X_test, y_test) . - ValueError Traceback (most recent call last) &lt;ipython-input-13-4b70515c7cdf&gt; in &lt;module&gt; 2 3 model = RandomForestRegressor() -&gt; 4 model.fit(X_train, y_train) 5 model.score(X_test, y_test) E: machine_learning env lib site-packages sklearn ensemble _forest.py in fit(self, X, y, sample_weight) 293 &#34;&#34;&#34; 294 # Validate or convert input data --&gt; 295 X = check_array(X, accept_sparse=&#34;csc&#34;, dtype=DTYPE) 296 y = check_array(y, accept_sparse=&#39;csc&#39;, ensure_2d=False, dtype=None) 297 if sample_weight is not None: E: machine_learning env lib site-packages sklearn utils validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, warn_on_dtype, estimator) 529 array = array.astype(dtype, casting=&#34;unsafe&#34;, copy=False) 530 else: --&gt; 531 array = np.asarray(array, order=order, dtype=dtype) 532 except ComplexWarning: 533 raise ValueError(&#34;Complex data not supported n&#34; E: machine_learning env lib site-packages numpy core _asarray.py in asarray(a, dtype, order) 83 84 &#34;&#34;&#34; &gt; 85 return array(a, dtype, copy=False, order=order) 86 87 ValueError: could not convert string to float: &#39;BMW&#39; . Why is there an error? . Because machine learning models can&#39;t handle strings, so we need to convert those strings into numbers. . So let&#39;s turn the categories into numbers: . from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer categorical_features = [&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;] one_hot = OneHotEncoder() transformer = ColumnTransformer([(&quot;one_hot&quot;, one_hot, categorical_features)], remainder=&quot;passthrough&quot;) transformed_X = transformer.fit_transform(X) transformed_X . array([[0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00, 0.00000e+00, 3.54310e+04], [1.00000e+00, 0.00000e+00, 0.00000e+00, ..., 0.00000e+00, 1.00000e+00, 1.92714e+05], [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00, 0.00000e+00, 8.47140e+04], ..., [0.00000e+00, 0.00000e+00, 1.00000e+00, ..., 1.00000e+00, 0.00000e+00, 6.66040e+04], [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00, 0.00000e+00, 2.15883e+05], [0.00000e+00, 0.00000e+00, 0.00000e+00, ..., 1.00000e+00, 0.00000e+00, 2.48360e+05]]) . pd.DataFrame(transformed_X) . 0 1 2 3 4 5 6 7 8 9 10 11 12 . 0 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 1.0 | 0.0 | 35431.0 | . 1 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 192714.0 | . 2 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 1.0 | 0.0 | 84714.0 | . 3 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 1.0 | 0.0 | 154365.0 | . 4 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 181577.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 995 0.0 | 0.0 | 0.0 | 1.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 35820.0 | . 996 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 1.0 | 0.0 | 0.0 | 155144.0 | . 997 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 66604.0 | . 998 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 1.0 | 0.0 | 215883.0 | . 999 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | 1.0 | 0.0 | 248360.0 | . 1000 rows × 13 columns . What OneHotEncoder does under the hood: . . dummies = pd.get_dummies(car_sales[[&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;]]) dummies . Doors Make_BMW Make_Honda Make_Nissan Make_Toyota Colour_Black Colour_Blue Colour_Green Colour_Red Colour_White . 0 4 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | . 1 5 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | . 2 4 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | . 3 4 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | . 4 3 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 995 4 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | . 996 3 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | . 997 4 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | . 998 4 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | . 999 4 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | . 1000 rows × 10 columns . Let&#39;s refit the model: . np.random.seed(2020) X_train, X_test, y_train, y_test = train_test_split(transformed_X, y, test_size=0.2) model.fit(X_train, y_train) . RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) . model.score(X_test, y_test) . 0.19383319494749351 . Why the score is so low? . --Intentionally blank line-- . 3. What if there were missing values? . Fill them with some value (also known as imputation). | Remove the samples with missing data altogether. | This time let&#39;s import a car sales dataset with missing values: . car_sales_missing = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv&quot;) car_sales_missing.head() . Make Colour Odometer (KM) Doors Price . 0 Honda | White | 35431.0 | 4.0 | 15323.0 | . 1 BMW | Blue | 192714.0 | 5.0 | 19943.0 | . 2 Honda | White | 84714.0 | 4.0 | 28343.0 | . 3 Toyota | White | 154365.0 | 4.0 | 13434.0 | . 4 Nissan | Blue | 181577.0 | 3.0 | 14043.0 | . car_sales_missing.isna().sum() . Make 49 Colour 50 Odometer (KM) 50 Doors 50 Price 50 dtype: int64 . Create X &amp; y: . X = car_sales_missing.drop(&quot;Price&quot;, axis=1) y = car_sales_missing[&quot;Price&quot;] . Let&#39;s try and convert our data to numbers. . Turn the categories into numbers: . from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer categorical_features = [&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;] one_hot = OneHotEncoder() transformer = ColumnTransformer([(&quot;one_hot&quot;, one_hot, categorical_features)], remainder=&quot;passthrough&quot;) transformed_X = transformer.fit_transform(X) transformed_X . - ValueError Traceback (most recent call last) &lt;ipython-input-22-c22fbfad0141&gt; in &lt;module&gt; 9 remainder=&#34;passthrough&#34;) 10 &gt; 11 transformed_X = transformer.fit_transform(X) 12 transformed_X E: machine_learning env lib site-packages sklearn compose _column_transformer.py in fit_transform(self, X, y) 516 self._validate_remainder(X) 517 --&gt; 518 result = self._fit_transform(X, y, _fit_transform_one) 519 520 if not result: E: machine_learning env lib site-packages sklearn compose _column_transformer.py in _fit_transform(self, X, y, func, fitted) 446 self._iter(fitted=fitted, replace_strings=True)) 447 try: --&gt; 448 return Parallel(n_jobs=self.n_jobs)( 449 delayed(func)( 450 transformer=clone(trans) if not fitted else trans, E: machine_learning env lib site-packages joblib parallel.py in __call__(self, iterable) 1002 # remaining jobs. 1003 self._iterating = False -&gt; 1004 if self.dispatch_one_batch(iterator): 1005 self._iterating = self._original_iterator is not None 1006 E: machine_learning env lib site-packages joblib parallel.py in dispatch_one_batch(self, iterator) 833 return False 834 else: --&gt; 835 self._dispatch(tasks) 836 return True 837 E: machine_learning env lib site-packages joblib parallel.py in _dispatch(self, batch) 752 with self._lock: 753 job_idx = len(self._jobs) --&gt; 754 job = self._backend.apply_async(batch, callback=cb) 755 # A job can complete so quickly than its callback is 756 # called before we get here, causing self._jobs to E: machine_learning env lib site-packages joblib _parallel_backends.py in apply_async(self, func, callback) 207 def apply_async(self, func, callback=None): 208 &#34;&#34;&#34;Schedule a func to be run&#34;&#34;&#34; --&gt; 209 result = ImmediateResult(func) 210 if callback: 211 callback(result) E: machine_learning env lib site-packages joblib _parallel_backends.py in __init__(self, batch) 588 # Don&#39;t delay the application, to avoid keeping the input 589 # arguments in memory --&gt; 590 self.results = batch() 591 592 def get(self): E: machine_learning env lib site-packages joblib parallel.py in __call__(self) 253 # change the default number of processes to -1 254 with parallel_backend(self._backend, n_jobs=self._n_jobs): --&gt; 255 return [func(*args, **kwargs) 256 for func, args, kwargs in self.items] 257 E: machine_learning env lib site-packages joblib parallel.py in &lt;listcomp&gt;(.0) 253 # change the default number of processes to -1 254 with parallel_backend(self._backend, n_jobs=self._n_jobs): --&gt; 255 return [func(*args, **kwargs) 256 for func, args, kwargs in self.items] 257 E: machine_learning env lib site-packages sklearn pipeline.py in _fit_transform_one(transformer, X, y, weight, message_clsname, message, **fit_params) 726 with _print_elapsed_time(message_clsname, message): 727 if hasattr(transformer, &#39;fit_transform&#39;): --&gt; 728 res = transformer.fit_transform(X, y, **fit_params) 729 else: 730 res = transformer.fit(X, y, **fit_params).transform(X) E: machine_learning env lib site-packages sklearn preprocessing _encoders.py in fit_transform(self, X, y) 370 &#34;&#34;&#34; 371 self._validate_keywords() --&gt; 372 return super().fit_transform(X, y) 373 374 def transform(self, X): E: machine_learning env lib site-packages sklearn base.py in fit_transform(self, X, y, **fit_params) 569 if y is None: 570 # fit method of arity 1 (unsupervised transformation) --&gt; 571 return self.fit(X, **fit_params).transform(X) 572 else: 573 # fit method of arity 2 (supervised transformation) E: machine_learning env lib site-packages sklearn preprocessing _encoders.py in fit(self, X, y) 345 &#34;&#34;&#34; 346 self._validate_keywords() --&gt; 347 self._fit(X, handle_unknown=self.handle_unknown) 348 self.drop_idx_ = self._compute_drop_idx() 349 return self E: machine_learning env lib site-packages sklearn preprocessing _encoders.py in _fit(self, X, handle_unknown) 72 73 def _fit(self, X, handle_unknown=&#39;error&#39;): &gt; 74 X_list, n_samples, n_features = self._check_X(X) 75 76 if self.categories != &#39;auto&#39;: E: machine_learning env lib site-packages sklearn preprocessing _encoders.py in _check_X(self, X) 58 for i in range(n_features): 59 Xi = self._get_feature(X, feature_idx=i) &gt; 60 Xi = check_array(Xi, ensure_2d=False, dtype=None, 61 force_all_finite=needs_validation) 62 X_columns.append(Xi) E: machine_learning env lib site-packages sklearn utils validation.py in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, warn_on_dtype, estimator) 575 576 if force_all_finite: --&gt; 577 _assert_all_finite(array, 578 allow_nan=force_all_finite == &#39;allow-nan&#39;) 579 E: machine_learning env lib site-packages sklearn utils validation.py in _assert_all_finite(X, allow_nan, msg_dtype) 63 elif X.dtype == np.dtype(&#39;object&#39;) and not allow_nan: 64 if _object_dtype_isnan(X).any(): &gt; 65 raise ValueError(&#34;Input contains NaN&#34;) 66 67 ValueError: Input contains NaN . Why there is an error? . Because machine learning model can&#39;t possess unfulfiled datasets. . car_sales_missing[&quot;Doors&quot;].value_counts() . 4.0 811 5.0 75 3.0 64 Name: Doors, dtype: int64 . Option 1: Fill missing data with Pandas . Learn more about filling missing values with pandas: https://www.geeksforgeeks.org/python-pandas-dataframe-fillna-to-replace-null-values-in-dataframe/ . # Fill the &quot;Make&quot; column car_sales_missing[&quot;Make&quot;].fillna(&quot;missing&quot;, inplace=True) # Fill the &quot;Colour&quot; column car_sales_missing[&quot;Colour&quot;].fillna(&quot;missing&quot;, inplace=True) # Fill the &quot;Odometer (KM)&quot; column car_sales_missing[&quot;Odometer (KM)&quot;].fillna(car_sales_missing[&quot;Odometer (KM)&quot;].mean(), inplace=True) # Fill the &quot;Doors&quot; column car_sales_missing[&quot;Doors&quot;].fillna(4, inplace=True) . # Check our dataframe again car_sales_missing.isna().sum() . Make 0 Colour 0 Odometer (KM) 0 Doors 0 Price 50 dtype: int64 . # Remove rows with missing Price value car_sales_missing.dropna(inplace=True) . car_sales_missing.isna().sum() . Make 0 Colour 0 Odometer (KM) 0 Doors 0 Price 0 dtype: int64 . Now we have lost 50 data because of the removed data in &quot;Price&quot; column. . len(car_sales_missing) . 950 . The missing values are all filled or removed, so we can convert them. . X = car_sales_missing.drop(&quot;Price&quot;, axis=1) y = car_sales_missing[&quot;Price&quot;] . Let&#39;s try and convert our data to numbers. Turn the categories into numbers: . from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer categorical_features = [&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;] one_hot = OneHotEncoder() transformer = ColumnTransformer([(&quot;one_hot&quot;, one_hot, categorical_features)], remainder=&quot;passthrough&quot;) transformed_X = transformer.fit_transform(car_sales_missing) transformed_X . array([[0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00, 3.54310e+04, 1.53230e+04], [1.00000e+00, 0.00000e+00, 0.00000e+00, ..., 1.00000e+00, 1.92714e+05, 1.99430e+04], [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00, 8.47140e+04, 2.83430e+04], ..., [0.00000e+00, 0.00000e+00, 1.00000e+00, ..., 0.00000e+00, 6.66040e+04, 3.15700e+04], [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00, 2.15883e+05, 4.00100e+03], [0.00000e+00, 0.00000e+00, 0.00000e+00, ..., 0.00000e+00, 2.48360e+05, 1.27320e+04]]) . Option 2: Filling missing data and transforming categorical data with Scikit-Learn . The main takeaways: . Split your data first, always keep your training &amp; test data separate | Fill/transform the training set and test sets separately | . # standard imports import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline . car_sales_missing = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv&quot;) car_sales_missing.head() . Make Colour Odometer (KM) Doors Price . 0 Honda | White | 35431.0 | 4.0 | 15323.0 | . 1 BMW | Blue | 192714.0 | 5.0 | 19943.0 | . 2 Honda | White | 84714.0 | 4.0 | 28343.0 | . 3 Toyota | White | 154365.0 | 4.0 | 13434.0 | . 4 Nissan | Blue | 181577.0 | 3.0 | 14043.0 | . # Check missing values car_sales_missing.isna().sum() . Make 49 Colour 50 Odometer (KM) 50 Doors 50 Price 50 dtype: int64 . # Drop the rows with no labels car_sales_missing.dropna(subset=[&quot;Price&quot;], inplace=True) car_sales_missing.isna().sum() . Make 47 Colour 46 Odometer (KM) 48 Doors 47 Price 0 dtype: int64 . Note the data is split before any filling or transformations. . from sklearn.model_selection import train_test_split # Split into X &amp; y X = car_sales_missing.drop(&quot;Price&quot;, axis=1) y = car_sales_missing[&quot;Price&quot;] # Split data into train and test np.random.seed(2020) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) . # Check missing values X.isna().sum() . Make 47 Colour 46 Odometer (KM) 48 Doors 47 dtype: int64 . Let&#39;s fill the missing values. . We must fill the training and test values separately to ensure training data stays with the training dta and test data stays with the test data. . Note: We use fit_transform() on the training data and transform() on the testing data. In essence, we learn the patterns in the training set and transform it via imputation (fit, then transform). Then we take those same patterns and fill the test set (transform only). . # Fill missing values with Scikit-Learn from sklearn.impute import SimpleImputer from sklearn.compose import ColumnTransformer # Fill categorical values with &#39;missing&#39; &amp; numerical values with mean cat_imputer = SimpleImputer(strategy=&quot;constant&quot;, fill_value=&quot;missing&quot;) door_imputer = SimpleImputer(strategy=&quot;constant&quot;, fill_value=4) num_imputer = SimpleImputer(strategy=&quot;mean&quot;) # Define columns cat_features = [&quot;Make&quot;, &quot;Colour&quot;] door_feature = [&quot;Doors&quot;] num_features = [&quot;Odometer (KM)&quot;] # Create an imputer (something that fills missing data) imputer = ColumnTransformer([ (&quot;cat_imputer&quot;, cat_imputer, cat_features), (&quot;door_imputer&quot;, door_imputer, door_feature), (&quot;num_imputer&quot;, num_imputer, num_features) ]) # Fill train and test values separately filled_X_train = imputer.fit_transform(X_train) filled_X_test = imputer.transform(X_test) # Check filled X_train filled_X_train . array([[&#39;Nissan&#39;, &#39;Blue&#39;, 3.0, 24219.0], [&#39;Honda&#39;, &#39;Blue&#39;, 4.0, 219217.0], [&#39;Nissan&#39;, &#39;White&#39;, 4.0, 152215.0], ..., [&#39;Toyota&#39;, &#39;White&#39;, 4.0, 112292.0], [&#39;Toyota&#39;, &#39;White&#39;, 4.0, 83594.0], [&#39;Nissan&#39;, &#39;White&#39;, 3.0, 131296.40416666667]], dtype=object) . Now we&#39;ve filled our missing values, let&#39;s check how many are missing from each set. (Should be 0) . # Get our transformed data arrays back into DataFrames car_sales_filled_train = pd.DataFrame(filled_X_train, columns=[&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;, &quot;Odometer (KM)&quot;]) car_sales_filled_test = pd.DataFrame(filled_X_test, columns=[&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;, &quot;Odometer (KM)&quot;]) # Check missing data in training set car_sales_filled_train.isna().sum() . Make 0 Colour 0 Doors 0 Odometer (KM) 0 dtype: int64 . # Check missing data in test set car_sales_filled_test.isna().sum() . Make 0 Colour 0 Doors 0 Odometer (KM) 0 dtype: int64 . Look! No more missing values! . # Check to see the original... still missing values car_sales_missing.isna().sum() . Make 47 Colour 46 Odometer (KM) 48 Doors 47 Price 0 dtype: int64 . Ok, no more missing values but we&#39;ve still got to turn our data into numbers. . Let&#39;s do that using one hot encoding. . Again, keeping our training and test data separate. . # Import OneHotEncoder class from sklearn from sklearn.preprocessing import OneHotEncoder # Now let&#39;s one hot encode the features with the same code as before categorical_features = [&quot;Make&quot;, &quot;Colour&quot;, &quot;Doors&quot;] one_hot = OneHotEncoder() transformer = ColumnTransformer([(&quot;one_hot&quot;, one_hot, categorical_features)], remainder=&quot;passthrough&quot;) # Fill train and test values separately transformed_X_train = transformer.fit_transform(car_sales_filled_train) transformed_X_test = transformer.transform(car_sales_filled_test) # Check transformed and filled X_train transformed_X_train.toarray() . array([[0.00000000e+00, 0.00000000e+00, 1.00000000e+00, ..., 0.00000000e+00, 0.00000000e+00, 2.42190000e+04], [0.00000000e+00, 1.00000000e+00, 0.00000000e+00, ..., 1.00000000e+00, 0.00000000e+00, 2.19217000e+05], [0.00000000e+00, 0.00000000e+00, 1.00000000e+00, ..., 1.00000000e+00, 0.00000000e+00, 1.52215000e+05], ..., [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ..., 1.00000000e+00, 0.00000000e+00, 1.12292000e+05], [0.00000000e+00, 0.00000000e+00, 0.00000000e+00, ..., 1.00000000e+00, 0.00000000e+00, 8.35940000e+04], [0.00000000e+00, 0.00000000e+00, 1.00000000e+00, ..., 0.00000000e+00, 0.00000000e+00, 1.31296404e+05]]) . Fit a model . Wonderful! Now we&#39;ve filled and transformed our data, ensuring the training and test sets have been kept separate. Let&#39;s fit a model to the training set and evaluate it on the test set. . # Since we&#39;ve transformed X, let&#39;s see if we can fit a model np.random.seed(2020) from sklearn.ensemble import RandomForestRegressor # Setup model model = RandomForestRegressor() # Make sure to use transformed (filled and one-hot encoded X data) model.fit(transformed_X_train, y_train) model.score(transformed_X_test, y_test) . 0.07839674412816233 . Why the score is even lower than the previous one? . --Becaue of the data we lost-- . len(car_sales), len(car_sales_missing) . (1000, 950) . The process of filling missing values is called Imputation. . The process of turn non-numerical values into numerical values is called Feature Engineering or Fearure Encoding. .",
            "url": "https://www.ai4love.xyz//2020/04/04/Splitting-Your-Data.html",
            "relUrl": "/2020/04/04/Splitting-Your-Data.html",
            "date": " • Apr 4, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Introduction to Scikit-Learn",
            "content": "This notebook records the 8.1 lesson of Daniel&#39;s ML course. He provides a summary of the chapter 8, which is listed below: . An end-to-end Scikit-Learn workflow | Getting the data ready | Choose the right estimator/algorithm for our problems | Fit the model/algorithm and use it to make predictions on our data | Evaluating a model | Improve a model | Save and load a trained model | Putting it all together | In this lesson, we focus only on the first section—An end-to-end Scikit-Learn workflow. This section is a brief overview of the entire chapter 8. Therefore, the content of this section can be a bit overwelming. There is no need to fully understand every points in this part. Its main purpose is only give students an opportunity to preview what they are going to learn later to better understand and use sklearn. . Daniel, the instructor of this course, shows every step of a common sklearn workflow in a simple version. Those steps are &quot;1. GET THE DATA READY&quot;, &quot;2. CHOOSE THE RIGHT MODEL AND HYPERPARAMETERS&quot;, &quot;3. FIT THE MODEL TO THE TRAINING DATA&quot;, &quot;4. EVALUATE THE MODEL ON THE TRAINING DATA AND TEST DATA&quot;, &quot;5. IMPROVE A MODEL&quot;, &quot;6. SAVE A MODEL AND LOAD IT&quot;. The last step in the list above is missing for unknown reasons. . 1. GET THE DATA READY . The first thing we need to do is not importing the data, but rather, importing some common libraries, such as pandas, numpy, matplotlib, and sklearn. But for now, let&#39;s just import the first two. . import pandas as pd import numpy as np . You may ask what the hell is pandas or numpy? . Let me explain... . &quot;Pandas&quot; is a software library writtten for the Python programming language for data manipulation and analysis. More specificly, it offers data structrues and operations for manipulating numerical tables and time series. . &quot;Numpy is a library for the Python programming language, adding support for large, multi-dimenstional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays. . Hooo, that&#39;s a lot to take in, but we may be ok for now. . After we import pandas and numpy, let&#39;s import the heart disease data from Github: . heart_disease = pd.read_csv(&quot;https://raw.githubusercontent.com/CongLiu-CN/zero-to-mastery-ml/master/data/heart-disease.csv&quot;) heart_disease.head() . age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target . 0 63 | 1 | 3 | 145 | 233 | 1 | 0 | 150 | 0 | 2.3 | 0 | 0 | 1 | 1 | . 1 37 | 1 | 2 | 130 | 250 | 0 | 1 | 187 | 0 | 3.5 | 0 | 0 | 2 | 1 | . 2 41 | 0 | 1 | 130 | 204 | 0 | 0 | 172 | 0 | 1.4 | 2 | 0 | 2 | 1 | . 3 56 | 1 | 1 | 120 | 236 | 0 | 1 | 178 | 0 | 0.8 | 2 | 0 | 2 | 1 | . 4 57 | 0 | 0 | 120 | 354 | 0 | 1 | 163 | 1 | 0.6 | 2 | 0 | 2 | 1 | . Why do we need to split data into X &amp; y? . --Intentionally blank line-- . X = heart_disease.drop(&quot;target&quot;, axis=1) y = heart_disease[&quot;target&quot;] . 2. Choose the right model and hyperparameters . from sklearn.ensemble import RandomForestClassifier clf = RandomForestClassifier() . # We&#39;ll keep the deafault hyperparameters clf.get_params() . {&#39;bootstrap&#39;: True, &#39;ccp_alpha&#39;: 0.0, &#39;class_weight&#39;: None, &#39;criterion&#39;: &#39;gini&#39;, &#39;max_depth&#39;: None, &#39;max_features&#39;: &#39;auto&#39;, &#39;max_leaf_nodes&#39;: None, &#39;max_samples&#39;: None, &#39;min_impurity_decrease&#39;: 0.0, &#39;min_impurity_split&#39;: None, &#39;min_samples_leaf&#39;: 1, &#39;min_samples_split&#39;: 2, &#39;min_weight_fraction_leaf&#39;: 0.0, &#39;n_estimators&#39;: 100, &#39;n_jobs&#39;: None, &#39;oob_score&#39;: False, &#39;random_state&#39;: None, &#39;verbose&#39;: 0, &#39;warm_start&#39;: False} . 3. Fit the model to the training data . What does train_test_split do? . Split arrays or matrices(the plural of the word Matrix) into random train and test subsets...https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html . from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) . clf.fit(X_train, y_train); . Make a prediction: . y_preds = clf.predict(X_test) y_preds . array([0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0], dtype=int64) . y_test . 256 0 24 1 266 0 294 0 131 1 .. 14 1 146 1 275 0 25 1 168 0 Name: target, Length: 61, dtype: int64 . 4. Evaluate the model on the training data and test data . clf.score(X_train, y_train) . 1.0 . clf.score(X_test, y_test) . 0.9016393442622951 . from sklearn.metrics import classification_report, confusion_matrix, accuracy_score . print(classification_report(y_test, y_preds)) . precision recall f1-score support 0 0.92 0.86 0.89 28 1 0.89 0.94 0.91 33 accuracy 0.90 61 macro avg 0.90 0.90 0.90 61 weighted avg 0.90 0.90 0.90 61 . confusion_matrix(y_test, y_preds) . array([[24, 4], [ 2, 31]], dtype=int64) . accuracy_score(y_test, y_preds) . 0.9016393442622951 . 5. Improve a model . Try different amount of n_estimators . np.random.seed(2020) . for i in range(10, 100, 10): print(f&quot;Trying model with {i} estimators...&quot;) clf = RandomForestClassifier(n_estimators=i).fit(X_train, y_train) print(f&quot;Model accuracy on test set: {clf.score(X_test, y_test)*100:.2f}%&quot;) print(&quot;&quot;) . Trying model with 10 estimators... Model accuracy on test set: 78.69% Trying model with 20 estimators... Model accuracy on test set: 90.16% Trying model with 30 estimators... Model accuracy on test set: 85.25% Trying model with 40 estimators... Model accuracy on test set: 88.52% Trying model with 50 estimators... Model accuracy on test set: 90.16% Trying model with 60 estimators... Model accuracy on test set: 90.16% Trying model with 70 estimators... Model accuracy on test set: 86.89% Trying model with 80 estimators... Model accuracy on test set: 85.25% Trying model with 90 estimators... Model accuracy on test set: 91.80% . 6. Save a model and load it . What is pickle? . https://www.pitt.edu/~naraehan/python3/pickling.html . import pickle . pickle.dump(clf, open(&quot;random_forest_model_1.pkl&quot;, &quot;wb&quot;)) . loaded_model = pickle.load(open(&quot;random_forest_model_1.pkl&quot;, &quot;rb&quot;)) loaded_model.score(X_test, y_test) # align with the last result . 0.9180327868852459 .",
            "url": "https://www.ai4love.xyz//2020/04/03/Introduction-to-Scikit-Learn.html",
            "relUrl": "/2020/04/03/Introduction-to-Scikit-Learn.html",
            "date": " • Apr 3, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hello, this is Cong Liu(刘聪), a self-taught programmer. . LinkedIn | GitHub | Ted Translator | Machine Learning Blog | Resume | . Online Courses . Udemy - Complete Machine Learning and Data Science: Zero to Mastery (July 7, 2020) . | Udemy - Complete Python Developer: Zero to Mastery (March 9, 2020) . | Udemy - Technical Support Fundamentals (March 23, 2020) . | Udemy - Master the Coding Interview: Data Structures+Algorithms (July 7, 2019) . | Udemy - Advanced JavaScript Concepts (July 3, 2019) . | MongoDB - M220JS: MongoDB for JavaScript Developers (Jun 18, 2019) . | Udemy - The Complete Web Developer in 2019: Zero to Mastery (April 30, 2019) . | freeCodeCamp - Responsive Web Design (March 2, 2019) . | . Work Experience . New Oriental, English Learning Assistant, Sep 17, 2019 - Jan 7, 2020 | Mappypals, Front-end Developer, May 20, 2019 - Jul 30, 2019 | CCD(Singapore), Chemical Technician, Dec 12, 2016 – May 5, 2018 | . Education Experience . China University of Petroleum (east china), Bachelor of Engineering, Sep 2012 - Jun 2016 | . Environmental Protection Equipment Engineering .",
          "url": "https://www.ai4love.xyz//about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}